/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitHubSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  githubToken: "",
  repoOwner: "",
  repoName: "",
  // Repository name, to be filled by the user.
  branch: "main",
  syncPath: "",
  // Default to empty string for repository root.
  autoSync: true,
  // Automatic synchronization enabled by default.
  syncInterval: 3e5,
  // Default sync interval: 5 minutes (in milliseconds).
  conflictResolution: "ask",
  // User is prompted for conflict resolution by default.
  realtimeSync: false,
  // Real-time sync is deliberately disabled by default.
  syncOnSave: false,
  // Sync-on-save is deliberately disabled by default.
  lastSyncTime: 0,
  notificationVerbosity: "standard"
  // Standard notification verbosity.
};
var RECENTLY_PUSHED_GRACE_PERIOD_MS = 90 * 1e3;
var RECENTLY_DELETED_GRACE_PERIOD_MS = 120 * 1e3;
var ConflictResolutionModal = class extends import_obsidian.Modal {
  constructor(app, fileName, localContent, remoteContent) {
    super(app);
    this.fileName = fileName;
    this.localContent = localContent;
    this.remoteContent = remoteContent;
  }
  // Called when the modal is opened. Configures its content and styling.
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: `Conflict in: ${this.fileName}` });
    contentEl.createEl("p", { text: "The file has been modified both locally and remotely. How would you like to resolve this conflict?" });
    const contentDisplayContainer = contentEl.createDiv({ cls: "conflict-content-display" });
    contentDisplayContainer.style.display = "flex";
    contentDisplayContainer.style.gap = "15px";
    contentDisplayContainer.style.marginTop = "20px";
    contentDisplayContainer.style.width = "100%";
    const localColumn = contentDisplayContainer.createDiv({ cls: "local-column" });
    localColumn.style.flex = "1";
    localColumn.style.display = "flex";
    localColumn.style.flexDirection = "column";
    localColumn.createEl("h3", { text: "Your Local Version", cls: "text-lg font-semibold" });
    const localTextarea = localColumn.createEl("textarea", { cls: "w-full h-64 border rounded p-2 text-sm font-mono" });
    localTextarea.value = this.localContent;
    localTextarea.readOnly = true;
    localTextarea.style.minHeight = "150px";
    localTextarea.style.maxHeight = "300px";
    localTextarea.style.overflow = "auto";
    localTextarea.style.resize = "vertical";
    localTextarea.style.fontFamily = "monospace";
    const remoteColumn = contentDisplayContainer.createDiv({ cls: "remote-column" });
    remoteColumn.style.flex = "1";
    remoteColumn.style.display = "flex";
    remoteColumn.style.flexDirection = "column";
    remoteColumn.createEl("h3", { text: "GitHub Version", cls: "text-lg font-semibold" });
    const remoteTextarea = remoteColumn.createEl("textarea", { cls: "w-full h-64 border rounded p-2 text-sm font-mono" });
    remoteTextarea.value = this.remoteContent;
    remoteTextarea.readOnly = true;
    remoteTextarea.style.minHeight = "150px";
    remoteTextarea.style.maxHeight = "300px";
    remoteTextarea.style.overflow = "auto";
    remoteTextarea.style.resize = "vertical";
    remoteTextarea.style.fontFamily = "monospace";
    const buttonContainer = contentEl.createDiv({ cls: "conflict-buttons" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.marginTop = "20px";
    const keepLocalBtn = buttonContainer.createEl("button", { text: "Keep Local Version" });
    keepLocalBtn.onclick = () => {
      this.close();
      this.resolve("local");
    };
    const keepRemoteBtn = buttonContainer.createEl("button", { text: "Keep Remote Version" });
    keepRemoteBtn.onclick = () => {
      this.close();
      this.resolve("remote");
    };
    const mergeBtn = buttonContainer.createEl("button", { text: "Try Auto-Merge" });
    mergeBtn.onclick = () => {
      this.close();
      this.resolve("merge");
    };
  }
  // Presents the modal and returns a promise that resolves with the user's chosen resolution.
  askForResolution() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      this.open();
    });
  }
};
var GitHubSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    // Reference to the plugin's status bar item.
    this.apiBase = "https://api.github.com";
    // Debounced function for sync-on-save behavior.
    this.fileWatchers = /* @__PURE__ */ new Map();
  }
  // Debounced notice display function.
  // Called when the plugin is loaded.
  async onload() {
    console.log("Loading GitHub SyncMate plugin...");
    this.syncState = {
      inProgress: false,
      lastSync: 0,
      // Will be loaded from settings.
      pendingFiles: /* @__PURE__ */ new Set(),
      fileMetadata: /* @__PURE__ */ new Map(),
      pendingDeletions: /* @__PURE__ */ new Map(),
      recentlyPushedFiles: /* @__PURE__ */ new Map(),
      recentlyDeletedFromRemote: /* @__PURE__ */ new Map(),
      lastActiveFile: null,
      remoteChangesPendingForActiveFiles: /* @__PURE__ */ new Set()
    };
    await this.loadPluginData();
    this.settings.realtimeSync = false;
    this.settings.syncOnSave = false;
    await this.savePluginData();
    this.setupUI();
    this.setupEventListeners();
    this.updateOverallStatusBar();
    if (this.settings.notificationVerbosity === "verbose") {
      new import_obsidian.Notice("GitHub SyncMate: Plugin Loaded and Ready.", 2e3);
    }
    this.debouncedShowNotice = customDebounce((message, type, customDuration) => {
      let duration = customDuration || 2e3;
      if (type === "success") {
        duration = customDuration || 2e3;
      } else if (type === "error") {
        duration = customDuration || 5e3;
      } else if (type === "info") {
        duration = customDuration || 3e3;
      }
      new import_obsidian.Notice(message, duration);
    }, 1e3);
    this.debouncedSync = customDebounce((syncType = "Auto Sync", filePath) => {
      if (!this.syncState.inProgress) {
        console.log(`Debounced sync triggered (${syncType}).`);
        this.syncWithGitHub(syncType, filePath);
      } else {
        console.log(`Debounced sync (${syncType}): Sync already in progress, skipping.`);
      }
    }, 2e3);
    this.debouncedSaveOnCloseSync = customDebounce(async (file) => {
      if (!this.syncState.inProgress && this.shouldSyncFile(file)) {
        const localFileState = (await this.getLocalFileStates()).get(file.path);
        const metadata = this.syncState.fileMetadata.get(file.path);
        if (localFileState && metadata && localFileState.checksum !== metadata.remoteContentChecksum) {
          console.log(`[SaveOnClose Sync] Triggering sync for ${file.path} due to active leaf change and local modifications.`);
          this.syncState.pendingFiles.add(file.path);
          this.syncWithGitHub("Save on Close Sync", file.path);
        } else {
          console.log(`[SaveOnClose Sync] No changes detected for ${file.path} on active leaf change, skipping sync.`);
        }
      }
    }, 500);
    if (this.settings.autoSync) {
      console.log("GitHub SyncMate: Initiating sync on startup...");
      this.debouncedSync("Startup Sync");
      this.startAutoSync();
    }
    if (this.isMobile()) {
      this.optimizeForMobile();
    }
  }
  // Called when the plugin is unloaded.
  onunload() {
    this.stopAutoSync();
    this.clearFileWatchers();
    console.log("GitHub SyncMate Plugin unloaded.");
  }
  // Sets up the plugin's user interface elements, including ribbon icon, status bar, commands, and context menus.
  setupUI() {
    console.log("[Plugin Setup] setupUI method called.");
    this.addRibbonIcon("sync", "GitHub SyncMate", () => {
      this.syncWithGitHub("Manual Sync");
    });
    this.statusBarItem = this.addStatusBarItem();
    this.addCommand({
      id: "sync-with-github",
      name: "Sync with GitHub",
      callback: () => this.syncWithGitHub("Manual Sync")
    });
    this.addCommand({
      id: "force-pull",
      name: "Force Pull from GitHub",
      callback: () => this.forcePullFromGitHub()
    });
    this.addCommand({
      id: "force-push",
      name: "Force Push to GitHub",
      callback: () => this.forcePushToGitHub()
    });
    this.addCommand({
      id: "view-file-history",
      name: "Show GitHub File History",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile instanceof import_obsidian.TFile && this.shouldSyncFile(activeFile)) {
          if (!checking) {
            this.openFileHistoryModal(activeFile);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "view-folder-history",
      name: "Show GitHub Folder History",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        let targetFolder = null;
        if (activeFile instanceof import_obsidian.TFolder) {
          targetFolder = activeFile;
        } else if (activeFile instanceof import_obsidian.TFile) {
          targetFolder = activeFile.parent;
        }
        if (targetFolder) {
          if (!checking) {
            this.openFolderHistoryModal(targetFolder);
          }
          return true;
        }
        return false;
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, abstractFile) => {
        if (abstractFile instanceof import_obsidian.TFile && this.shouldSyncFile(abstractFile)) {
          menu.addItem((item) => {
            item.setTitle("Show GitHub File History").setIcon("git-compare").onClick(() => this.openFileHistoryModal(abstractFile));
          });
        } else if (abstractFile instanceof import_obsidian.TFolder) {
          menu.addItem((item) => {
            item.setTitle("Show GitHub Folder History").setIcon("folder-git-2").onClick(() => this.openFolderHistoryModal(abstractFile));
          });
        }
      })
    );
    this.addSettingTab(new GitHubSyncSettingTab(this.app, this));
  }
  // Sets up event listeners for file system changes (modify, create, delete, rename).
  setupEventListeners() {
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile && this.shouldSyncFile(file)) {
        this.onFileModified(file);
      }
    }));
    this.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian.TFile && this.shouldSyncFile(file)) {
        this.onFileCreated(file);
      }
    }));
    this.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian.TFile && this.shouldSyncFile(file)) {
        this.onFileDeleted(file);
      }
    }));
    this.registerEvent(this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian.TFile && (this.shouldSyncFile(file) || this.shouldSyncPath(oldPath))) {
        this.onFileRenamed(file, oldPath);
      }
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      var _a;
      const previouslyActiveFile = this.syncState.lastActiveFile;
      const currentActiveFile = (leaf == null ? void 0 : leaf.view) instanceof import_obsidian.MarkdownView ? leaf.view.file : null;
      if (previouslyActiveFile && previouslyActiveFile instanceof import_obsidian.TFile && previouslyActiveFile !== currentActiveFile) {
        if (this.settings.syncOnSave && !this.settings.realtimeSync) {
          console.log(`[Event Handler] Active leaf changed from ${previouslyActiveFile.path}. Checking for SaveOnClose sync.`);
          this.debouncedSaveOnCloseSync(previouslyActiveFile);
        }
        if (this.syncState.remoteChangesPendingForActiveFiles.has(previouslyActiveFile.path)) {
          console.log(`[Event Handler] Previously active file ${previouslyActiveFile.path} is now inactive and had pending remote changes. Triggering pull.`);
          const remoteFileMetadata = (_a = await this.getRemoteFileStates()) == null ? void 0 : _a.get(previouslyActiveFile.path);
          if (remoteFileMetadata) {
            try {
              await this.downloadFile(remoteFileMetadata);
              this.syncState.remoteChangesPendingForActiveFiles.delete(previouslyActiveFile.path);
              this.debouncedShowNotice(`Remote changes for '${previouslyActiveFile.basename}' pulled successfully.`, "success", 2e3);
            } catch (pullError) {
              console.error(`[Event Handler] Failed to pull pending remote changes for ${previouslyActiveFile.path}:`, pullError);
              this.debouncedShowNotice(`Failed to pull remote changes for '${previouslyActiveFile.basename}'. Check console.`, "error");
            }
          } else {
            console.warn(`[Event Handler] Could not find remote metadata for ${previouslyActiveFile.path} despite pending remote changes. Clearing pending status.`);
            this.syncState.remoteChangesPendingForActiveFiles.delete(previouslyActiveFile.path);
          }
        }
      }
      this.syncState.lastActiveFile = currentActiveFile;
    }));
  }
  // Handles local file modification events.
  async onFileModified(file) {
    console.log(`[Event Handler] File modified: ${file.path}. Current Settings: RealtimeSync=${this.settings.realtimeSync}, SyncOnSave=${this.settings.syncOnSave}`);
    await this.updateFileMetadata(file);
    const localFileState = (await this.getLocalFileStates()).get(file.path);
    const metadata = this.syncState.fileMetadata.get(file.path);
    if (localFileState && metadata && localFileState.checksum !== metadata.remoteContentChecksum) {
      this.syncState.pendingFiles.add(file.path);
      console.log(`[Event Handler] Added ${file.path} to pending files for push (local content changed). Current pending: ${Array.from(this.syncState.pendingFiles).join(", ")}`);
    } else if (localFileState && metadata && localFileState.checksum === metadata.remoteContentChecksum) {
      this.syncState.pendingFiles.delete(file.path);
      console.log(`[Event Handler] Removed ${file.path} from pending files (content matches remote).`);
    } else if (!metadata) {
      this.syncState.pendingFiles.add(file.path);
      console.log(`[Event Handler] Added new file ${file.path} to pending files for push.`);
    }
    if (this.settings.realtimeSync || this.settings.syncOnSave && !this.settings.realtimeSync) {
      this.debouncedSync("Real-time sync", file.path);
    } else {
      console.log(`[Event Handler] Not triggering automated real-time sync for ${file.path}. RealtimeSync: ${this.settings.realtimeSync}.`);
    }
    console.log(`[Event Handler] Updated metadata for ${file.path}.`);
  }
  // Handles local file creation events.
  async onFileCreated(file) {
    console.log(`[Event Handler] File created: ${file.path}. Current Settings: RealtimeSync=${this.settings.realtimeSync}, SyncOnSave=${this.settings.syncOnSave}`);
    await this.updateFileMetadata(file);
    const metadata = this.syncState.fileMetadata.get(file.path);
    if (metadata && metadata.localChecksum !== metadata.remoteContentChecksum) {
      this.syncState.pendingFiles.add(file.path);
      console.log(`[Event Handler] Added ${file.path} to pending files (new or locally changed). Current pending: ${Array.from(this.syncState.pendingFiles).join(", ")}`);
    } else if (metadata && metadata.localChecksum === metadata.remoteContentChecksum) {
      this.syncState.pendingFiles.delete(file.path);
      console.log(`[Event Handler] Removed ${file.path} from pending files (content matches remote after creation/pull).`);
    } else {
      this.syncState.pendingFiles.add(file.path);
      console.log(`[Event Handler] Added truly new local file ${file.path} to pending files.`);
    }
    if (this.settings.realtimeSync || this.settings.syncOnSave && !this.settings.realtimeSync) {
      this.debouncedSync("Real-time sync", file.path);
    } else {
      console.log(`[Event Handler] Not triggering automated real-time sync for ${file.path}. RealtimeSync: ${this.settings.realtimeSync}.`);
    }
    console.log(`[Event Handler] Updated metadata for ${file.path}.`);
  }
  // Handles local file deletion events.
  async onFileDeleted(file) {
    console.log(`[Event Handler] File deleted locally: ${file.path}`);
    const metadata = this.syncState.fileMetadata.get(file.path);
    if (metadata && metadata.githubBlobSha) {
      this.syncState.pendingDeletions.set(file.path, metadata.githubBlobSha);
      console.log(`[Event Handler] Marked ${file.path} for remote deletion with SHA: ${metadata.githubBlobSha}`);
    } else {
      console.log(`[Event Handler] ${file.path} was not tracked with a remote SHA, not marking for remote deletion.`);
    }
    this.syncState.fileMetadata.delete(file.path);
    this.syncState.pendingFiles.delete(file.path);
    this.syncState.remoteChangesPendingForActiveFiles.delete(file.path);
    if (this.settings.realtimeSync || this.settings.autoSync) {
      this.debouncedSync("Real-time sync", file.path);
    }
    await this.savePluginData();
  }
  // Handles local file renaming events.
  async onFileRenamed(file, oldPath) {
    console.log(`[Event Handler] File renamed: ${oldPath} -> ${file.path}`);
    const oldMetadata = this.syncState.fileMetadata.get(oldPath);
    if (oldMetadata && oldMetadata.githubBlobSha) {
      this.syncState.pendingDeletions.set(oldPath, oldMetadata.githubBlobSha);
      console.log(`[Event Handler] Marked old path ${oldPath} for remote deletion due to rename.`);
    }
    this.syncState.pendingFiles.delete(oldPath);
    this.syncState.fileMetadata.delete(oldPath);
    this.syncState.remoteChangesPendingForActiveFiles.delete(oldPath);
    console.log(`[Event Handler] Removed old path ${oldPath} from pending files and metadata.`);
    const newMetadata = {
      path: file.path,
      githubBlobSha: (oldMetadata == null ? void 0 : oldMetadata.githubBlobSha) || "",
      // Inherits SHA from old path if it existed.
      lastModified: file.stat.mtime,
      localChecksum: await this.calculateChecksum(await this.app.vault.read(file)),
      remoteContentChecksum: (oldMetadata == null ? void 0 : oldMetadata.remoteContentChecksum) || "",
      // Inherits remote checksum.
      conflicted: false
    };
    this.syncState.fileMetadata.set(file.path, newMetadata);
    console.log(`[Metadata] Created new metadata for ${file.path} (from rename): ${JSON.stringify(newMetadata)}`);
    this.syncState.pendingFiles.add(file.path);
    console.log(`[Event Handler] Added new path ${file.path} to pending files for push. Current pending: ${Array.from(this.syncState.pendingFiles).join(", ")}`);
    if (this.settings.realtimeSync || this.settings.autoSync) {
      this.debouncedSync("Real-time sync", file.path);
    }
    await this.savePluginData();
  }
  // Updates the metadata for a given file.
  async updateFileMetadata(file) {
    try {
      const content = await this.app.vault.read(file);
      const checksum = await this.calculateChecksum(content);
      let metadata = this.syncState.fileMetadata.get(file.path);
      if (!metadata) {
        metadata = {
          path: file.path,
          githubBlobSha: "",
          // No remote SHA yet.
          lastModified: file.stat.mtime,
          localChecksum: checksum,
          remoteContentChecksum: "",
          // No remote content checksum yet.
          conflicted: false
        };
        console.log(`[Metadata] Created new metadata for ${file.path}: ${JSON.stringify(metadata)}`);
      } else {
        metadata.localChecksum = checksum;
        metadata.lastModified = file.stat.mtime;
        metadata.conflicted = false;
        console.log(`[Metadata] Updated existing metadata for ${file.path}: ${JSON.stringify(metadata)}`);
      }
      this.syncState.fileMetadata.set(file.path, metadata);
      await this.savePluginData();
    } catch (error) {
      console.error(`[Metadata Error] Failed to update metadata for ${file.path}:`, error);
    }
  }
  // Calculates the SHA-256 checksum of file content.
  async calculateChecksum(content) {
    if (typeof crypto !== "undefined" && crypto.subtle) {
      const encoder = new TextEncoder();
      const data = encoder.encode(content);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    } else {
      let hash = 0;
      for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return hash.toString();
    }
  }
  // Initiates the main synchronization process with GitHub.
  async syncWithGitHub(syncType = "Auto Sync", specificFilePath) {
    var _a, _b, _c;
    if (!this.validateSettings() || this.syncState.inProgress) {
      if (this.syncState.inProgress) {
        this.debouncedShowNotice("Sync in progress, please wait.", "info");
      }
      return;
    }
    this.syncState.inProgress = true;
    let success = true;
    let error = null;
    const changesMade = {
      pushedCount: 0,
      pulledCount: 0,
      deletedLocallyCount: 0,
      deletedRemotelyCount: 0
    };
    const isRealtime = syncType === "Real-time sync" || syncType === "Save on Close Sync";
    const isStartupSync = syncType === "Startup Sync";
    const isQuietMode = this.settings.notificationVerbosity === "quiet";
    const isStandardMode = this.settings.notificationVerbosity === "standard";
    const isVerboseMode = this.settings.notificationVerbosity === "verbose";
    try {
      if (isStartupSync) {
        this.updateStatusBar("Startup sync in progress... \u23F3");
      } else if (isRealtime) {
        const fileName = specificFilePath ? (_a = this.app.metadataCache.getFirstLinkpathDest(specificFilePath, "")) == null ? void 0 : _a.basename : "";
        this.updateStatusBar(`Syncing${fileName ? " " + fileName : ""}... \u23F3`);
      } else {
        this.updateStatusBar(`Syncing (${syncType})... \u23F3`);
      }
      if (isStartupSync) {
        this.debouncedShowNotice(`GitHub SyncMate: Starting initial vault synchronization...`, "info", 2e3);
      } else if (!isRealtime || isVerboseMode) {
        this.debouncedShowNotice(`GitHub SyncMate: Starting ${syncType.toLowerCase()}...`, "info", 1500);
      }
      console.log(`[SyncWithGitHub] ${syncType}: Starting GitHub sync...`);
      console.log(`[SyncWithGitHub] Current pending files at start of sync: ${Array.from(this.syncState.pendingFiles).join(", ")}`);
      console.log(`[SyncWithGitHub] Current pending deletions at start of sync: ${Array.from(this.syncState.pendingDeletions.keys()).join(", ")}`);
      const localFiles = await this.getLocalFileStates();
      changesMade.deletedRemotelyCount = await this.processPendingDeletions();
      let remoteFiles = await this.getRemoteFileStates();
      const conflicts = await this.detectConflicts(localFiles, remoteFiles);
      await this.resolveConflicts(conflicts, syncType);
      const { pushedCount, pulledCount, deletedLocallyCount } = await this.performSync(localFiles, remoteFiles);
      changesMade.pushedCount = pushedCount;
      changesMade.pulledCount = pulledCount;
      changesMade.deletedLocallyCount = deletedLocallyCount;
      this.syncState.lastSync = Date.now();
      this.settings.lastSyncTime = this.syncState.lastSync;
      await this.savePluginData();
      const totalChanges = changesMade.pushedCount + changesMade.pulledCount + changesMade.deletedLocallyCount + changesMade.deletedRemotelyCount;
      if (isStartupSync) {
        this.updateStatusBar("Vault synced \u2728");
        this.debouncedShowNotice(`GitHub SyncMate: Vault synchronized. ${changesMade.pushedCount} files uploaded, ${changesMade.pulledCount} files downloaded.`, "success", 3e3);
      } else if (isRealtime) {
        if (isQuietMode) {
          if (totalChanges > 0) {
            console.log(`[SyncWithGitHub] Real-time sync completed with ${totalChanges} changes (quiet mode).`);
          }
        } else if (totalChanges === 0) {
        } else if (totalChanges === 1) {
          let successMessage = "";
          const fileName = specificFilePath ? (_b = this.app.metadataCache.getFirstLinkpathDest(specificFilePath, "")) == null ? void 0 : _b.basename : "";
          if (changesMade.pushedCount === 1 && fileName) successMessage = `\u2705 '${fileName}' uploaded.`;
          else if (changesMade.pulledCount === 1 && fileName) successMessage = `\u2B07\uFE0F '${fileName}' downloaded.`;
          else if (changesMade.deletedRemotelyCount === 1) {
            successMessage = fileName ? `\u{1F5D1}\uFE0F '${fileName}' deleted from GitHub.` : `\u{1F5D1}\uFE0F A file deleted from GitHub.`;
          } else if (changesMade.deletedLocallyCount === 1) {
            successMessage = fileName ? `\u{1F5D1}\uFE0F '${fileName}' deleted locally.` : `\u{1F5D1}\uFE0F A file deleted locally.;`;
          } else {
            successMessage = `\u2705 1 file synced.`;
          }
          if (successMessage) {
            this.debouncedShowNotice(successMessage, "success", 1500);
          }
        } else {
          const message = `GitHub SyncMate: ${totalChanges} changes processed (${changesMade.pushedCount} uploaded, ${changesMade.pulledCount} downloaded).`;
          this.debouncedShowNotice(message, "success", 3e3);
        }
      } else {
        let successMessage = `${syncType}: Sync completed.`;
        if (changesMade.pushedCount > 0) successMessage += ` Pushed ${changesMade.pushedCount} file(s).`;
        if (changesMade.pulledCount > 0) successMessage += ` Pulled ${changesMade.pulledCount} file(s).`;
        if (changesMade.deletedLocallyCount > 0) successMessage += ` Deleted ${changesMade.deletedLocallyCount} local file(s).`;
        if (changesMade.deletedRemotelyCount > 0) successMessage += ` Deleted ${changesMade.deletedRemotelyCount} remote file(s).`;
        if (totalChanges === 0) {
          successMessage += ` No changes detected.`;
        }
        this.debouncedShowNotice(successMessage, "success");
      }
      console.log(`[SyncWithGitHub] ${syncType}: GitHub sync completed successfully.`);
    } catch (e) {
      success = false;
      error = e;
      console.error("[SyncWithGitHub Error] Sync error:", error);
      let errorFileName = specificFilePath ? (_c = this.app.metadataCache.getFirstLinkpathDest(specificFilePath, "")) == null ? void 0 : _c.basename : "";
      const errorMessage = `GitHub SyncMate: ${isRealtime && errorFileName ? `Failed to sync '${errorFileName}'.` : "Failed to sync changes."} Error: ${(error == null ? void 0 : error.message) || "Unknown error"}. Please check your connection or plugin settings.`;
      this.debouncedShowNotice(errorMessage, "error", 5e3);
      this.updateStatusBar(isStartupSync ? "Startup sync error \u26A0\uFE0F" : isRealtime ? "Sync Error! \u2757" : "Sync Failed!");
    } finally {
      this.syncState.inProgress = false;
      await this.savePluginData();
      this.updateOverallStatusBar();
    }
  }
  // Detects conflicts between local and remote file states.
  async detectConflicts(localFiles, remoteFiles) {
    const conflicts = /* @__PURE__ */ new Map();
    if (remoteFiles === null) {
      console.warn("[Conflict Detection] Skipping remote-based conflict detection due to unreliable remote file states.");
      for (const [path, localFile] of localFiles) {
        const metadata = this.syncState.fileMetadata.get(path);
        if (!metadata || localFile.checksum !== metadata.remoteContentChecksum) {
          this.syncState.pendingFiles.add(path);
          console.log(`[Conflict Detection] Local file ${path} has changes or is new (no/outdated metadata). Adding to pending for push.`);
        }
      }
      return conflicts;
    }
    for (const [path, localFile] of localFiles) {
      const remoteFileMetadata = remoteFiles.get(path);
      let metadata = this.syncState.fileMetadata.get(path);
      if (!remoteFileMetadata) {
        if (!this.syncState.pendingDeletions.has(path) && (!metadata || !metadata.githubBlobSha)) {
          console.log(`[Conflict Detection] New local file ${path} detected, will be pushed.`);
          this.syncState.pendingFiles.add(path);
        } else {
          console.log(`[Conflict Detection] File ${path} exists locally but is missing remotely (remote deletion detected or not tracked).`);
        }
        continue;
      }
      if (!metadata) {
        console.log(`[Conflict Detection] No metadata for ${path} but exists locally and remotely. Fetching remote content to establish initial state.`);
        try {
          const remoteContentData = await this.makeGitHubRequest(
            `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${this.encodeFilePath(remoteFileMetadata.path)}?ref=${this.settings.branch}`
          );
          const remoteContent = this.decodeBase64(remoteContentData.content);
          const remoteChecksum = await this.calculateChecksum(remoteContent);
          const newMetadata = {
            path,
            githubBlobSha: remoteFileMetadata.sha,
            lastModified: localFile.mtime,
            // Uses local mtime for initial metadata.
            localChecksum: localFile.checksum,
            remoteContentChecksum: remoteChecksum,
            conflicted: false
          };
          this.syncState.fileMetadata.set(path, newMetadata);
          metadata = newMetadata;
          console.log(`[Conflict Detection] Initial metadata established for ${path}.`);
          if (localFile.checksum !== metadata.remoteContentChecksum) {
            console.log(`[Conflict Detection] Local content differs from remote after initial metadata fetch for ${path}. Adding to pending for push.`);
            this.syncState.pendingFiles.add(path);
          } else {
            console.log(`[Conflict Detection] Local content matches remote for ${path} after initial metadata fetch. Not adding to pending.`);
            this.syncState.pendingFiles.delete(path);
          }
        } catch (fetchError) {
          console.error(`[Conflict Detection Error] Failed to fetch remote content for ${path} to resolve missing metadata:`, fetchError);
          this.debouncedShowNotice(`Warning: Could not fetch remote content for '${path}'. Sync accuracy might be affected.`, "error");
          this.syncState.pendingFiles.add(path);
        }
        continue;
      }
      const localChanged = localFile.checksum !== metadata.remoteContentChecksum;
      const remoteChanged = remoteFileMetadata.sha !== metadata.githubBlobSha;
      const localPending = this.syncState.pendingFiles.has(path);
      console.log(`[Conflict Detection] For ${path}:`);
      console.log(`  Local Checksum: ${localFile.checksum}`);
      console.log(`  Metadata Remote Content Checksum: ${metadata.remoteContentChecksum}`);
      console.log(`  Local Changed: ${localChanged}`);
      console.log(`  Remote SHA: ${remoteFileMetadata.sha}`);
      console.log(`  Metadata GitHub Blob SHA: ${metadata.githubBlobSha}`);
      console.log(`  Remote Changed: ${remoteChanged}`);
      console.log(`  Local Pending: ${localPending}`);
      if (localChanged && remoteChanged) {
        console.warn(`[Conflict Detection] Potential conflict detected for ${path}. Fetching remote content for resolution.`);
        const remoteContentData = await this.makeGitHubRequest(
          `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${this.encodeFilePath(remoteFileMetadata.path)}?ref=${this.settings.branch}`
        );
        const remoteContent = this.decodeBase64(remoteContentData.content);
        conflicts.set(path, {
          local: localFile,
          remote: { ...remoteFileMetadata, content: remoteContent },
          metadata
        });
        this.syncState.pendingFiles.add(path);
        console.warn(`[Conflict Detection] Conflict added to list for ${path}`);
      } else if (localChanged && !remoteChanged) {
        console.log(`[Conflict Detection] File ${path} has local changes and no remote changes. Will push.`);
        this.syncState.pendingFiles.add(path);
      } else if (!localChanged && remoteChanged) {
        console.log(`[Conflict Detection] File ${path} has remote changes and no local pending changes. Will pull.`);
        this.syncState.pendingFiles.delete(path);
      } else {
        console.log(`[Conflict Detection] No significant changes or no conflict for ${path}.`);
        this.syncState.pendingFiles.delete(path);
      }
    }
    for (const [path, remoteFileMetadata] of remoteFiles) {
      const localFile = localFiles.get(path);
      if (!localFile && !this.syncState.pendingDeletions.has(path)) {
        console.log(`[Conflict Detection] File ${path} exists remotely but not locally. Will be pulled.`);
      }
    }
    return conflicts;
  }
  // Resolves detected conflicts based on the configured strategy or user input.
  async resolveConflicts(conflicts, syncType) {
    if (conflicts.size === 0) {
      console.log("[Conflict Resolution] No conflicts to resolve.");
      return;
    }
    const isRealtimeOrSaveOnClose = syncType === "Real-time sync" || syncType === "Save on Close Sync";
    const isQuietMode = this.settings.notificationVerbosity === "quiet";
    if (!isQuietMode) {
      this.debouncedShowNotice(`Resolving ${conflicts.size} conflicts...`, "info");
    }
    for (const [path, conflict] of conflicts.entries()) {
      let effectiveResolution;
      if (this.settings.conflictResolution === "ask" && !isRealtimeOrSaveOnClose) {
        const modal = new ConflictResolutionModal(this.app, path, conflict.local.content, conflict.remote.content);
        effectiveResolution = await modal.askForResolution();
        console.log(`[Conflict Resolution] User selected resolution for ${path}: ${effectiveResolution}`);
      } else if (this.settings.conflictResolution === "ask" && isRealtimeOrSaveOnClose) {
        if (!isQuietMode) {
          new import_obsidian.Notice(`\u{1F6A8} Conflict detected in '${path}'! Kept local version to avoid interruption. Please review and sync manually if needed.`, 8e3);
        }
        this.updateStatusBar(`Conflict in '${path}' \u26A0\uFE0F`);
        effectiveResolution = "local";
      } else {
        effectiveResolution = this.settings.conflictResolution;
        console.log(`[Conflict Resolution] Applying automatic resolution for ${path}: ${effectiveResolution}`);
      }
      await this.applyConflictResolution(path, conflict, effectiveResolution);
    }
  }
  // Applies the chosen conflict resolution to a specific file.
  async applyConflictResolution(path, conflict, resolution) {
    const file = this.app.vault.getAbstractFileByPath(path);
    console.log(`[Apply Conflict Resolution] Applying resolution for ${path}: ${resolution}`);
    const isQuietMode = this.settings.notificationVerbosity === "quiet";
    switch (resolution) {
      case "local":
        this.syncState.pendingFiles.add(path);
        if (!isQuietMode) {
          this.debouncedShowNotice(`Conflict resolved for ${path}: Kept local version.`, "info");
        }
        break;
      case "remote":
        if (file) {
          await this.app.vault.modify(file, conflict.remote.content);
          const checksum = await this.calculateChecksum(conflict.remote.content);
          const metadata = this.syncState.fileMetadata.get(path);
          if (metadata) {
            metadata.localChecksum = checksum;
            metadata.remoteContentChecksum = checksum;
            metadata.githubBlobSha = conflict.remote.sha;
          }
          this.syncState.pendingFiles.delete(path);
          if (!isQuietMode) {
            this.debouncedShowNotice(`Conflict resolved for ${path}: Kept remote version. (You may need to reopen the file to see changes.)`, "info");
          }
        } else {
          const localPath = this.getLocalPath(path);
          await this.ensureDirectoryExists(localPath);
          await this.app.vault.create(localPath, conflict.remote.content);
          const checksum = await this.calculateChecksum(conflict.remote.content);
          const metadata = {
            path: localPath,
            githubBlobSha: conflict.remote.sha,
            localChecksum: checksum,
            remoteContentChecksum: checksum,
            lastModified: Date.now(),
            conflicted: false
          };
          this.syncState.fileMetadata.set(localPath, metadata);
          if (!isQuietMode) {
            this.debouncedShowNotice(`Conflict resolved for ${path}: Created local file with remote version. (You may need to reopen the file to see changes.)`, "info");
          }
        }
        break;
      case "merge":
        const merged = await this.mergeContent(conflict.local.content, conflict.remote.content);
        if (file) {
          await this.app.vault.modify(file, merged);
          this.syncState.pendingFiles.add(path);
          if (!isQuietMode) {
            this.debouncedShowNotice(`Conflict resolved for ${path}: Auto-merged. (This version will be pushed.)`, "info");
          }
        }
        break;
    }
    await this.savePluginData();
  }
  // Attempts a basic content merge for conflicted files.
  async mergeContent(localContent, remoteContent) {
    const localLines = localContent.split("\n");
    const remoteLines = remoteContent.split("\n");
    const mergedLines = [...localLines];
    let hasNewRemoteLines = false;
    for (const remoteLine of remoteLines) {
      if (!localLines.includes(remoteLine)) {
        mergedLines.push(remoteLine);
        hasNewRemoteLines = true;
      }
    }
    if (hasNewRemoteLines) {
      return `<<<<<<< local version
${localContent}
=======
${remoteContent}
>>>>>>> remote version
`;
    }
    return localContent;
  }
  // Executes the core synchronization logic: pushing, pulling, and local deletions.
  async performSync(localFiles, currentRemoteFiles) {
    var _a;
    console.log("[Perform Sync] Performing sync operations...");
    const filesToPush = /* @__PURE__ */ new Set();
    const filesToPull = /* @__PURE__ */ new Set();
    const filesToDeleteLocally = /* @__PURE__ */ new Set();
    let pushedCount = 0;
    let pulledCount = 0;
    let deletedLocallyCount = 0;
    for (const path of this.syncState.pendingFiles) {
      const localFile = localFiles.get(path);
      if (localFile) {
        filesToPush.add(localFile.file);
        console.log(`[Perform Sync] File added to push queue: ${path}`);
      } else {
        console.warn(`[Perform Sync] Pending file ${path} not found locally, removing from pending and skipping push.`);
        this.syncState.pendingFiles.delete(path);
      }
    }
    for (const file of filesToPush) {
      try {
        const remotePath = this.getRemotePath(file.path);
        const metadata = this.syncState.fileMetadata.get(file.path);
        const activeFile = this.app.workspace.getActiveFile();
        const isActivelyEditing = activeFile && activeFile.path === file.path;
        if (!isActivelyEditing && this.settings.realtimeSync && metadata) {
          const remoteFileMetadata = currentRemoteFiles == null ? void 0 : currentRemoteFiles.get(file.path);
          if (remoteFileMetadata && remoteFileMetadata.sha !== metadata.githubBlobSha) {
            console.log(`[Perform Sync] Proactively pulling ${file.path} before push due to detected remote changes (not actively editing).`);
            await this.downloadFile(remoteFileMetadata);
            localFiles.set(file.path, (await this.getLocalFileStates()).get(file.path));
          } else {
            console.log(`[Perform Sync] Skipping proactive pull for ${file.path}: No remote changes detected or actively editing.`);
          }
        } else if (isActivelyEditing) {
          console.log(`[Perform Sync] Skipping proactive pull for ${file.path} as it's actively being edited.`);
        }
        await this.uploadFile(file);
        this.syncState.pendingFiles.delete(file.path);
        this.syncState.recentlyPushedFiles.set(file.path, Date.now());
        pushedCount++;
        console.log(`[Perform Sync] Successfully pushed and removed from pending: ${file.path}`);
      } catch (error) {
        console.error(`[Perform Sync Error] Failed to push ${file.path}:`, error);
        this.debouncedShowNotice(`Failed to push ${file.path}. Check console for details.`, "error");
      }
    }
    console.log("[Perform Sync] Re-fetching remote file states after push operations...");
    currentRemoteFiles = await this.getRemoteFileStates();
    if (currentRemoteFiles !== null) {
      for (const [path, remoteFileMetadata] of currentRemoteFiles) {
        const localFile = localFiles.get(path);
        const metadata = this.syncState.fileMetadata.get(path);
        if (!localFile) {
          if (!this.syncState.pendingDeletions.has(path)) {
            filesToPull.add(remoteFileMetadata);
            console.log(`[Perform Sync] File ${path} exists remotely but not locally. Will pull.`);
          } else {
            console.log(`[Perform Sync] File ${path} exists remotely but is marked for pending local deletion. Skipping pull.`);
          }
          continue;
        }
        if (metadata && remoteFileMetadata.sha !== metadata.githubBlobSha) {
          const activeFile = this.app.workspace.getActiveFile();
          const isActivelyEditing = activeFile && activeFile.path === path;
          if (isActivelyEditing) {
            if (!this.syncState.remoteChangesPendingForActiveFiles.has(path)) {
              this.syncState.remoteChangesPendingForActiveFiles.add(path);
              const fileName = ((_a = this.app.metadataCache.getFirstLinkpathDest(path, "")) == null ? void 0 : _a.basename) || path;
              if (this.settings.notificationVerbosity !== "quiet") {
                this.debouncedShowNotice(`Remote changes for '${fileName}' detected. Pull skipped to prevent overwrite. Close file to pull, or manually resolve.`, "info", 5e3);
              }
              console.log(`[Perform Sync] File ${path} has remote changes and is actively being edited. Adding to remoteChangesPendingForActiveFiles.`);
            } else {
              console.log(`[Perform Sync] File ${path} has remote changes and is actively being edited. Already noted as pending pull.`);
            }
          } else if (!filesToPush.has(localFile.file) || this.settings.conflictResolution === "remote") {
            filesToPull.add(remoteFileMetadata);
            this.syncState.remoteChangesPendingForActiveFiles.delete(path);
            console.log(`[Perform Sync] File ${path} has changed remotely and is not pending local push (or resolution is remote), and not actively edited. Will pull.`);
          } else {
            console.log(`[Perform Sync] File ${path} has remote changes but also pending local changes. Conflict was handled or will be pushed.`);
          }
        }
      }
      for (const [path, localFileState] of localFiles) {
        const remoteFileMetadata = currentRemoteFiles.get(path);
        const metadata = this.syncState.fileMetadata.get(path);
        const isRemoteMissing = !remoteFileMetadata;
        const wasTrackedRemotely = !!(metadata == null ? void 0 : metadata.githubBlobSha);
        const wasRecentlyPushed = this.syncState.recentlyPushedFiles.has(path) && Date.now() - this.syncState.recentlyPushedFiles.get(path) < RECENTLY_PUSHED_GRACE_PERIOD_MS;
        console.log(`[Perform Sync - Local Delete Check] For ${path}: isRemoteMissing=${isRemoteMissing}, wasRecentlyPushed=${wasRecentlyPushed}, wasTrackedRemotely=${wasTrackedRemotely}`);
        if (isRemoteMissing && wasTrackedRemotely && !wasRecentlyPushed) {
          filesToDeleteLocally.add(localFileState.file);
          console.log(`[Perform Sync] File ${path} exists locally but not remotely (remote deletion detected). Will delete locally.`);
        } else if (isRemoteMissing && wasRecentlyPushed) {
          console.warn(`[Perform Sync] File ${path} exists locally, was recently pushed, but still appears missing remotely. Skipping local deletion due to grace period.`);
        }
      }
      for (const file of filesToDeleteLocally) {
        try {
          await this.app.vault.delete(file);
          this.syncState.fileMetadata.delete(file.path);
          this.syncState.remoteChangesPendingForActiveFiles.delete(file.path);
          deletedLocallyCount++;
          console.log(`[Perform Sync] Successfully deleted local file ${file.path} (remote deletion detected).`);
        } catch (error) {
          console.error(`[Perform Sync Error] Failed to delete local file ${file.path}:`, error);
          this.debouncedShowNotice(`Failed to delete local file ${file.path}. Check console.`, "error");
        }
      }
    } else {
      console.warn("[Perform Sync] Skipping remote-to-local operations (pulls and local deletions) due to unreliable remote file states after push.");
      this.debouncedShowNotice("Skipping some pull/delete operations due to network issues after push. Please check connection and try again.", "error");
    }
    if (currentRemoteFiles !== null) {
      for (const remoteFileMetadata of filesToPull) {
        try {
          await this.downloadFile(remoteFileMetadata);
          pulledCount++;
        } catch (error) {
          console.error(`[Perform Sync Error] Failed to pull ${remoteFileMetadata.path}:`, error);
          this.debouncedShowNotice(`Failed to pull ${remoteFileMetadata.path}. Check console for details.`, "error");
        }
      }
    }
    const now = Date.now();
    for (const [path, timestamp] of this.syncState.recentlyPushedFiles.entries()) {
      if (now - timestamp > RECENTLY_PUSHED_GRACE_PERIOD_MS) {
        this.syncState.recentlyPushedFiles.delete(path);
        console.log(`[Recently Pushed Cache] Cleared ${path} from cache.`);
      }
    }
    for (const [path, timestamp] of this.syncState.recentlyDeletedFromRemote.entries()) {
      if (now - timestamp > RECENTLY_DELETED_GRACE_PERIOD_MS) {
        this.syncState.recentlyDeletedFromRemote.delete(path);
        console.log(`[Recently Deleted Cache] Cleared ${path} from cache (expired).`);
      }
    }
    return { pushedCount, pulledCount, deletedLocallyCount };
  }
  // Processes files marked for pending deletion from the remote repository.
  async processPendingDeletions() {
    console.log(`[Process Pending Deletions] Processing ${this.syncState.pendingDeletions.size} pending deletions.`);
    const successfulDeletions = /* @__PURE__ */ new Set();
    let deletedRemotelyCount = 0;
    for (const [path, sha] of this.syncState.pendingDeletions.entries()) {
      try {
        await this.deleteFileFromGitHub(path, sha);
        successfulDeletions.add(path);
        deletedRemotelyCount++;
        console.log(`[Process Pending Deletions] Successfully deleted ${path} from GitHub.`);
      } catch (error) {
        console.error(`[Process Pending Deletions Error] Failed to delete ${path} from GitHub:`, error);
        this.debouncedShowNotice(`Failed to delete ${path} from GitHub. Check console for details.`, "error");
      }
    }
    successfulDeletions.forEach((path) => this.syncState.pendingDeletions.delete(path));
    await this.savePluginData();
    return deletedRemotelyCount;
  }
  // Deletes a file from the GitHub repository, with retry logic.
  async deleteFileFromGitHub(filePath, initialFileSha, maxRetries = 3) {
    var _a;
    const remotePath = this.getRemotePath(filePath);
    console.log(`[Delete] Attempting to delete ${filePath} from GitHub at ${remotePath}`);
    for (let i = 0; i < maxRetries; i++) {
      let currentRemoteSha;
      try {
        const existingFileResponse = await this.makeGitHubRequest(
          `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${this.encodeFilePath(remotePath)}?ref=${this.settings.branch}`
        );
        if (existingFileResponse && !Array.isArray(existingFileResponse)) {
          currentRemoteSha = (_a = existingFileResponse.sha) != null ? _a : void 0;
          console.log(`[Delete] Found latest SHA for ${filePath}: ${currentRemoteSha} (Attempt ${i + 1}/${maxRetries})`);
        }
      } catch (error) {
        if (error.status === 404) {
          console.log(`[Delete] File ${filePath} already does not exist on GitHub (404 during pre-check). Considering deletion successful.`);
          this.syncState.recentlyDeletedFromRemote.set(filePath, Date.now());
          return;
        }
        console.error(`[Delete Error] Failed to get latest SHA for ${filePath} during pre-check (Attempt ${i + 1}/${maxRetries}):`, error);
        if (i < maxRetries - 1) {
          await new Promise((resolve) => setTimeout(resolve, 1e3 * (i + 1)));
          continue;
        }
        throw error;
      }
      if (!currentRemoteSha) {
        console.warn(`[Delete] Cannot delete ${filePath} from GitHub: No current SHA available after pre-check (Attempt ${i + 1}/${maxRetries}). Assuming it's already gone.`);
        this.syncState.recentlyDeletedFromRemote.set(filePath, Date.now());
        return;
      }
      try {
        await this.makeGitHubRequest(
          `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${this.encodeFilePath(remotePath)}`,
          {
            method: "DELETE",
            body: {
              message: `Delete ${filePath} (Obsidian SyncMate)`,
              sha: currentRemoteSha,
              branch: this.settings.branch
            }
          }
        );
        console.log(`[Delete] Successfully deleted ${filePath} from GitHub.`);
        this.syncState.recentlyDeletedFromRemote.set(filePath, Date.now());
        return;
      } catch (error) {
        if (error.status === 409 && i < maxRetries - 1) {
          console.warn(`[Delete Error] Conflict (409) for ${filePath}, retrying attempt ${i + 1}/${maxRetries}...`);
          await new Promise((resolve) => setTimeout(resolve, 1e3 * (i + 1)));
        } else if (error.status === 404) {
          console.log(`[Delete] File ${filePath} was already deleted on GitHub (404 during delete attempt). Considering deletion successful.`);
          this.syncState.recentlyDeletedFromRemote.set(filePath, Date.now());
          return;
        } else {
          console.error(`[Delete Error] Failed to delete ${filePath} from GitHub after ${i + 1} attempts:`, error);
          throw error;
        }
      }
    }
  }
  // Downloads a file from GitHub to the local vault.
  async downloadFile(fileInfo) {
    console.log(`[Download] Attempting to download ${fileInfo.path} (SHA: ${fileInfo.sha})`);
    try {
      const encodedFilePath = this.encodeFilePath(fileInfo.path);
      const downloadEndpoint = `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${encodedFilePath}?ref=${this.settings.branch}`;
      console.log(`[Download Debug] Constructed download endpoint: ${downloadEndpoint}`);
      const fileData = await this.makeGitHubRequest(
        downloadEndpoint
      );
      const remoteContent = this.decodeBase64(fileData.content);
      const localPath = this.getLocalPath(fileInfo.path);
      await this.ensureDirectoryExists(localPath);
      const existingFile = this.app.vault.getAbstractFileByPath(localPath);
      const remoteContentChecksum = await this.calculateChecksum(remoteContent);
      if (existingFile instanceof import_obsidian.TFile) {
        const localContent = await this.app.vault.read(existingFile);
        if (localContent !== remoteContent) {
          await this.app.vault.modify(existingFile, remoteContent);
          console.log(`[Download] Updated local file ${localPath} with remote version.`);
        } else {
          console.log(`[Download] Local file ${localPath} content is identical to remote, skipping modification.`);
        }
      } else {
        await this.app.vault.create(localPath, remoteContent);
        console.log(`[Download] Created new local file ${localPath}.`);
      }
      const metadata = this.syncState.fileMetadata.get(localPath) || {
        path: localPath,
        githubBlobSha: "",
        localChecksum: "",
        remoteContentChecksum: "",
        lastModified: Date.now(),
        conflicted: false
      };
      metadata.githubBlobSha = fileInfo.sha;
      metadata.remoteContentChecksum = remoteContentChecksum;
      metadata.localChecksum = remoteContentChecksum;
      metadata.lastModified = Date.now();
      this.syncState.fileMetadata.set(localPath, metadata);
      this.syncState.pendingFiles.delete(localPath);
      this.syncState.remoteChangesPendingForActiveFiles.delete(localPath);
      console.log(`[Download] Removed ${localPath} from pending files after successful pull.`);
      await this.savePluginData();
    } catch (error) {
      console.error(`[Download Error] Error downloading file ${fileInfo.path}:`, error);
      throw error;
    }
  }
  // Loads plugin data (settings and file metadata) from Obsidian's storage.
  async loadPluginData() {
    const storedData = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, storedData.settings);
    const loadedMetadata = /* @__PURE__ */ new Map();
    if (storedData.fileMetadata) {
      for (const [path, data] of Object.entries(storedData.fileMetadata)) {
        loadedMetadata.set(path, {
          path,
          githubBlobSha: data.githubBlobSha || data.sha || "",
          localChecksum: data.localChecksum || "",
          remoteContentChecksum: data.remoteContentChecksum || data.remoteChecksum || "",
          lastModified: data.lastModified || 0,
          conflicted: data.conflicted || false
        });
      }
    }
    this.syncState.fileMetadata = loadedMetadata;
    this.syncState.pendingDeletions = new Map(Object.entries(storedData.pendingDeletions || {}));
    this.syncState.remoteChangesPendingForActiveFiles = new Set(storedData.remoteChangesPendingForActiveFiles || []);
    this.syncState.lastSync = this.settings.lastSyncTime;
    console.log("Plugin data loaded successfully.");
  }
  // Saves plugin data (settings and file metadata) to Obsidian's storage.
  async savePluginData() {
    const dataToSave = {
      settings: this.settings,
      fileMetadata: Object.fromEntries(this.syncState.fileMetadata),
      pendingDeletions: Object.fromEntries(this.syncState.pendingDeletions),
      remoteChangesPendingForActiveFiles: Array.from(this.syncState.remoteChangesPendingForActiveFiles)
    };
    await this.saveData(dataToSave);
    console.log("Plugin data saved successfully.");
  }
  // Clears all active file watchers.
  clearFileWatchers() {
    for (const [path, unwatch] of this.fileWatchers) {
      unwatch();
    }
    this.fileWatchers.clear();
  }
  // Checks if the current environment is likely a mobile device.
  isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "ontouchstart" in window || window.innerWidth <= 768;
  }
  // Applies optimizations specific to mobile environments.
  optimizeForMobile() {
    if (this.settings.autoSync && this.settings.syncInterval < 6e5) {
      this.settings.syncInterval = 6e5;
      console.log("Mobile optimization: Sync interval adjusted to 10 minutes.");
    }
  }
  // Updates the text displayed in the Obsidian status bar.
  updateStatusBar(status) {
    this.statusBarItem.setText(`GitHub SyncMate: ${status}`);
  }
  // Updates the overall status bar message based on current sync state.
  updateOverallStatusBar() {
    if (this.syncState.inProgress) {
      return;
    }
    if (this.settings.realtimeSync) {
      this.updateStatusBar("Real-time sync active \u26A1");
    } else if (this.settings.autoSync) {
      this.updateStatusBar("Auto-sync active \u{1F504}");
    } else {
      this.updateStatusBar("Idle");
    }
  }
  // Starts the periodic auto-synchronization.
  startAutoSync() {
    this.stopAutoSync();
    console.log(`Starting auto-sync every ${this.settings.syncInterval / 6e4} minutes.`);
    this.syncIntervalId = window.setInterval(() => {
      this.syncWithGitHub("Auto Sync");
    }, this.settings.syncInterval);
    this.updateOverallStatusBar();
  }
  // Stops the periodic auto-synchronization.
  stopAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
      console.log("Auto-sync stopped.");
    }
    this.updateOverallStatusBar();
  }
  // Retrieves the current state (content and checksum) of local Markdown files.
  async getLocalFileStates() {
    const fileStates = /* @__PURE__ */ new Map();
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.shouldSyncFile(file)) {
        try {
          const content = await this.app.vault.cachedRead(file);
          const checksum = await this.calculateChecksum(content);
          fileStates.set(file.path, {
            file,
            content,
            checksum,
            mtime: file.stat.mtime
          });
        } catch (error) {
          console.warn(`Failed to read local file ${file.path}:`, error);
        }
      }
    }
    return fileStates;
  }
  // Retrieves metadata (path, SHA, type) for remote files from GitHub.
  async getRemoteFileStates() {
    const remoteStatesFromApi = /* @__PURE__ */ new Map();
    const syncPathClean = this.settings.syncPath.trim().replace(/^\/|\/$/g, "");
    const syncPathForApi = syncPathClean === "" ? "" : syncPathClean;
    const syncPathForApiEncoded = this.encodeFilePath(syncPathForApi);
    try {
      const contents = await this.makeGitHubRequest(
        `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${syncPathForApiEncoded}?ref=${this.settings.branch}`
      );
      if (Array.isArray(contents)) {
        await this.processRemoteDirectory(contents, remoteStatesFromApi);
      } else if (contents.type === "file" && this.isMarkdownFile(contents.name)) {
        remoteStatesFromApi.set(this.getLocalPath(contents.path), {
          path: contents.path,
          sha: contents.sha,
          type: contents.type
        });
      }
      const now = Date.now();
      const finalRemoteStates = /* @__PURE__ */ new Map();
      for (const [path, fileInfoFromApi] of remoteStatesFromApi) {
        const deletedTimestamp = this.syncState.recentlyDeletedFromRemote.get(path);
        if (deletedTimestamp && now - deletedTimestamp < RECENTLY_DELETED_GRACE_PERIOD_MS) {
          console.log(`[getRemoteFileStates] Filtering out ${path} from remote states: recently deleted.`);
          continue;
        }
        const metadata = this.syncState.fileMetadata.get(path);
        const pushedTimestamp = this.syncState.recentlyPushedFiles.get(path);
        if (pushedTimestamp && now - pushedTimestamp < RECENTLY_PUSHED_GRACE_PERIOD_MS && (metadata == null ? void 0 : metadata.githubBlobSha)) {
          if (metadata.githubBlobSha !== fileInfoFromApi.sha) {
            console.log(`[getRemoteFileStates] Augmenting ${path} remote SHA with local metadata's newer SHA (${metadata.githubBlobSha} vs API ${fileInfoFromApi.sha}) due-to recent push.`);
            finalRemoteStates.set(path, {
              ...fileInfoFromApi,
              sha: metadata.githubBlobSha
            });
            continue;
          }
        }
        finalRemoteStates.set(path, fileInfoFromApi);
      }
      for (const [path, timestamp] of this.syncState.recentlyPushedFiles.entries()) {
        if (now - timestamp > RECENTLY_PUSHED_GRACE_PERIOD_MS) {
          this.syncState.recentlyPushedFiles.delete(path);
          console.log(`[Recently Pushed Cache] Cleared ${path} from cache.`);
        }
      }
      for (const [path, timestamp] of this.syncState.recentlyDeletedFromRemote.entries()) {
        if (now - timestamp > RECENTLY_DELETED_GRACE_PERIOD_MS) {
          this.syncState.recentlyDeletedFromRemote.delete(path);
          console.log(`[Recently Deleted Cache] Cleared ${path} from cache (expired).`);
        }
      }
      return finalRemoteStates;
    } catch (error) {
      console.error("[getRemoteFileStates Error] Failed to get remote file states:", error);
      this.debouncedShowNotice("Failed to fetch remote file states. This may affect sync accuracy. Check your GitHub settings and network connection.", "error");
      return null;
    }
  }
  // Recursively processes items in a remote directory.
  async processRemoteDirectory(items, remoteStates) {
    for (const item of items) {
      if (item.type === "file" && this.isMarkdownFile(item.name)) {
        remoteStates.set(this.getLocalPath(item.path), {
          path: item.path,
          sha: item.sha,
          type: item.type
        });
      } else if (item.type === "dir") {
        try {
          const encodedItemPath = this.encodeFilePath(item.path);
          const subContents = await this.makeGitHubRequest(
            `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${encodedItemPath}?ref=${this.settings.branch}`
          );
          if (Array.isArray(subContents)) {
            await this.processRemoteDirectory(subContents, remoteStates);
          }
        } catch (error) {
          console.warn(`Failed to process remote directory ${item.path}:`, error);
        }
      }
    }
  }
  // Forces a pull of all files from GitHub, overwriting local versions.
  async forcePullFromGitHub() {
    if (!this.validateSettings()) return;
    if (this.syncState.inProgress) {
      this.debouncedShowNotice("Sync in progress, please wait before forcing a pull.", "info");
      return;
    }
    try {
      this.syncState.inProgress = true;
      this.updateStatusBar("Force pulling...");
      this.debouncedShowNotice("Starting force pull from GitHub...", "info");
      const remoteFilesMetadata = await this.getRemoteFileStates();
      if (remoteFilesMetadata === null) {
        this.debouncedShowNotice("Force pull aborted: Could not retrieve remote file states due to network issues.", "error");
        return;
      }
      let pulledCount = 0;
      for (const [path, remoteFileMetadata] of remoteFilesMetadata) {
        try {
          await this.downloadFile(remoteFileMetadata);
          pulledCount++;
        } catch (error) {
          console.error(`[Force Pull Error] Failed to pull ${path}:`, error);
          this.debouncedShowNotice(`Failed to pull ${path} during force pull. Check console.`, "error");
        }
      }
      this.syncState.lastSync = Date.now();
      this.settings.lastSyncTime = this.syncState.lastSync;
      await this.savePluginData();
      this.updateStatusBar("Force pull complete");
      this.debouncedShowNotice(`Force pull completed. Pulled ${pulledCount} file(s).`, "success");
      console.log("Force pull to GitHub completed.");
    } catch (error) {
      console.error("Force pull error:", error);
      this.debouncedShowNotice(`Force pull failed: ${error.message}`, "error");
    } finally {
      this.syncState.inProgress = false;
      this.updateOverallStatusBar();
    }
  }
  // Forces a push of all local files to GitHub, overwriting remote versions.
  async forcePushToGitHub() {
    if (!this.validateSettings()) return;
    if (this.syncState.inProgress) {
      this.debouncedShowNotice("Sync in progress, please wait before forcing a push.", "info");
      return;
    }
    try {
      this.syncState.inProgress = true;
      this.updateStatusBar("Force pushing...");
      this.debouncedShowNotice("Starting force push to GitHub...", "info");
      const files = this.app.vault.getMarkdownFiles();
      let pushedCount = 0;
      for (const file of files) {
        if (this.shouldSyncFile(file)) {
          try {
            await this.uploadFile(file, 1);
            pushedCount++;
          } catch (error) {
            console.error(`[Force Push Error] Failed to push ${file.path}:`, error);
            this.debouncedShowNotice(`Failed to push ${file.path} during force push. Check console.`, "error");
          }
        }
      }
      this.syncState.lastSync = Date.now();
      this.settings.lastSyncTime = this.syncState.lastSync;
      await this.savePluginData();
      this.updateStatusBar("Force push complete");
      this.debouncedShowNotice(`Force push completed. Pushed ${pushedCount} file(s).`, "success");
      console.log("Force push to GitHub completed.");
    } catch (error) {
      console.error("Force push error:", error);
      this.debouncedShowNotice(`Force push failed: ${error.message}`, "error");
    } finally {
      this.syncState.inProgress = false;
      this.updateOverallStatusBar();
    }
  }
  // Makes a request to the GitHub API with retry logic and error handling.
  async makeGitHubRequest(endpoint, options = {}, retries = 3, delay = 1e3) {
    const url = `${this.apiBase}${endpoint}`;
    const headers = {
      "Authorization": `token ${this.settings.githubToken}`,
      "Accept": "application/vnd.github.v3+json",
      "User-Agent": "Obsidian-GitHub-SyncMate/1.1.0",
      // User-Agent for API identification.
      ...options.headers
    };
    const requestOptions = {
      url,
      method: options.method || "GET",
      headers,
      ...options
    };
    if (options.body) {
      requestOptions.body = JSON.stringify(options.body);
      headers["Content-Type"] = "application/json";
    }
    let attempts = 0;
    while (attempts < retries) {
      attempts++;
      try {
        const response = await (0, import_obsidian.requestUrl)(requestOptions);
        if (response.status >= 400) {
          console.error(`GitHub API Error: ${response.status} - ${response.text}`, response);
          const error = new Error(`GitHub API Error: ${response.status} - ${response.text}`);
          error.status = response.status;
          throw error;
        }
        console.log(`GitHub Request successful for ${url} (Attempt ${attempts})`);
        return response.json;
      } catch (error) {
        console.error(`Request to ${url} failed (Attempt ${attempts}):`, error);
        const isRetryableError = error.message && (error.message.includes("net::ERR_TIMED_OUT") || error.message.includes("Failed to fetch")) || error.status && [500, 502, 503, 504, 409].includes(error.status);
        if (attempts < retries && isRetryableError) {
          console.log(`Retrying in ${delay / 1e3} seconds...`);
          await new Promise((res) => setTimeout(res, delay));
          delay *= 1.5;
        } else {
          if (error.request && error.request.response) {
            try {
              const errorJson = JSON.parse(error.request.response);
              if (errorJson.message) {
                const newError = new Error(`GitHub API Error: ${errorJson.message} (Status: ${error.status || "unknown"})`);
                newError.status = error.status;
                throw newError;
              }
            } catch (parseError) {
            }
          }
          throw error;
        }
      }
    }
    throw new Error("Max retries reached for GitHub request without successful response.");
  }
  // Determines if a given TFile should be synchronized based on sync path and file type.
  shouldSyncFile(file) {
    const syncPath = this.settings.syncPath;
    const filePath = file.path;
    const normalizedSyncPath = syncPath.replace(/^\/|\/$/g, "");
    if (normalizedSyncPath === "") {
      return this.isMarkdownFile(file.name);
    }
    const normalizedLocalPath = filePath.replace(/^\//, "");
    return normalizedLocalPath.startsWith(normalizedSyncPath + "/") && this.isMarkdownFile(file.name);
  }
  // Determines if a given path (string) should be synchronized.
  shouldSyncPath(path) {
    const syncPath = this.settings.syncPath;
    const normalizedSyncPath = syncPath.replace(/^\/|\/$/g, "");
    const normalizedPath = path.replace(/^\//, "");
    if (normalizedSyncPath === "") {
      return this.isMarkdownFile(path);
    }
    return normalizedPath.startsWith(normalizedSyncPath + "/") && this.isMarkdownFile(path);
  }
  // Converts a GitHub remote path to a local Obsidian vault path.
  getLocalPath(remotePath) {
    const syncPath = this.settings.syncPath;
    const normalizedSyncPath = syncPath.replace(/^\/|\/$/g, "");
    const normalizedRemotePath = remotePath.replace(/^\//, "");
    if (normalizedSyncPath === "") {
      return normalizedRemotePath;
    }
    if (normalizedRemotePath === normalizedSyncPath) {
      return "";
    }
    const expectedPrefix = `${normalizedSyncPath}/`;
    if (normalizedRemotePath.startsWith(expectedPrefix)) {
      return normalizedRemotePath.substring(expectedPrefix.length);
    }
    return normalizedRemotePath;
  }
  // Converts a local Obsidian vault path to a GitHub remote path.
  getRemotePath(localPath) {
    const normalizedLocalPath = localPath.replace(/^\//, "");
    const normalizedSyncPath = this.settings.syncPath.replace(/^\/|\/$/g, "");
    if (normalizedSyncPath === "") {
      return normalizedLocalPath;
    }
    if (normalizedLocalPath === "") {
      return normalizedSyncPath;
    }
    return `${normalizedSyncPath}/${normalizedLocalPath}`;
  }
  // Checks if a filename has a Markdown extension.
  isMarkdownFile(filename) {
    return filename.endsWith(".md") || filename.endsWith(".markdown");
  }
  // Encodes a string to Base64.
  encodeBase64(str) {
    try {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(str, "utf8").toString("base64");
      } else {
        const bytes = new TextEncoder().encode(str);
        let binaryString = "";
        for (let i = 0; i < bytes.length; i++) {
          binaryString += String.fromCharCode(bytes[i]);
        }
        return btoa(binaryString);
      }
    } catch (e) {
      console.error("Error during encodeBase64:", e);
      throw new Error("Failed to encode string to base64.");
    }
  }
  // Decodes a Base64 string.
  decodeBase64(str) {
    try {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(str, "base64").toString("utf8");
      } else {
        let cleanedStr = str.replace(/[^A-Za-z0-9+/=]/g, "");
        while (cleanedStr.length % 4 !== 0) {
          cleanedStr += "=";
        }
        console.log(`[decodeBase64] Cleaned string for atob: "${cleanedStr.substring(0, 100)}..." (length: ${cleanedStr.length})`);
        const binaryString = atob(cleanedStr);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return new TextDecoder("utf-8").decode(bytes);
      }
    } catch (e) {
      console.error("Error during decodeBase64:", e);
      if (e instanceof DOMException && e.name === "InvalidCharacterError") {
        throw new Error("Failed to decode base64 string: Input contains invalid base64 characters or incorrect padding. Please ensure the content on GitHub is valid.");
      } else if (e instanceof URIError) {
        throw new Error("Failed to decode base64 string: Malformed URI sequence after base64 decoding. This suggests problematic UTF-8 characters.");
      } else {
        throw new Error(`Failed to decode base64 string: ${e.message || e}`);
      }
    }
  }
  // Validates essential GitHub synchronization settings.
  validateSettings() {
    if (!this.settings.githubToken || !this.settings.repoOwner || !this.settings.repoName) {
      this.debouncedShowNotice("Please configure GitHub settings first (Token, Owner, Repo Name).", "error");
      return false;
    }
    return true;
  }
  // Tests the connection to the configured GitHub repository.
  async testConnection() {
    if (!this.validateSettings()) {
      return false;
    }
    try {
      console.log(`[Test Connection] Attempting to connect to: /repos/${this.settings.repoOwner}/${this.settings.repoName}`);
      await this.makeGitHubRequest(
        `/repos/${this.settings.repoOwner}/${this.settings.repoName}`
      );
      this.debouncedShowNotice("\u2705 Connection successful!", "success");
      console.log("[Test Connection] Connection successful.");
      return true;
    } catch (error) {
      console.error("[Test Connection] Connection failed:", error);
      this.debouncedShowNotice(`\u274C Connection failed: ${error.message}`, "error");
      throw new Error(`Connection failed: ${error.message}`);
    }
  }
  // Uploads a file to GitHub, handling existing files and retries.
  async uploadFile(file, maxRetries = 3) {
    var _a;
    const localContent = await this.app.vault.read(file);
    const remotePath = this.getRemotePath(file.path);
    console.log(`[Upload] Attempting to upload ${file.path} to ${remotePath}`);
    let currentAttempt = 0;
    let chosenConflictResolution = void 0;
    while (currentAttempt < maxRetries) {
      currentAttempt++;
      let currentRemoteSha;
      let remoteContentFromGitHub;
      let metadata = this.syncState.fileMetadata.get(file.path);
      if (!metadata) {
        metadata = {
          path: file.path,
          githubBlobSha: "",
          lastModified: file.stat.mtime,
          localChecksum: await this.calculateChecksum(localContent),
          remoteContentChecksum: "",
          conflicted: false
        };
        this.syncState.fileMetadata.set(file.path, metadata);
        await this.savePluginData();
      }
      try {
        const encodedRemotePath = this.encodeFilePath(remotePath);
        const existingFileResponse = await this.makeGitHubRequest(
          `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${encodedRemotePath}?ref=${this.settings.branch}`
        );
        if (existingFileResponse && !Array.isArray(existingFileResponse)) {
          currentRemoteSha = (_a = existingFileResponse.sha) != null ? _a : void 0;
          remoteContentFromGitHub = this.decodeBase64(existingFileResponse.content);
          metadata.remoteContentChecksum = await this.calculateChecksum(remoteContentFromGitHub);
          metadata.githubBlobSha = currentRemoteSha != null ? currentRemoteSha : "";
          await this.savePluginData();
          console.log(`[Upload] Fetched latest remote SHA (${currentRemoteSha}) and content for ${file.path} (Attempt ${currentAttempt}/${maxRetries}).`);
        }
      } catch (error) {
        if (error.status === 404) {
          console.log(`[Upload] File ${remotePath} doesn't exist on GitHub, will create new.`);
          currentRemoteSha = void 0;
          remoteContentFromGitHub = void 0;
        } else {
          console.error(`[Upload Error] Error fetching current SHA/content for ${remotePath} (Attempt ${currentAttempt}/${maxRetries}):`, error);
          throw error;
        }
      }
      const localChecksum = await this.calculateChecksum(localContent);
      let contentToPush = localContent;
      let shaForPut = currentRemoteSha;
      if (remoteContentFromGitHub !== void 0 && localContent !== remoteContentFromGitHub) {
        console.warn(`[Upload] Detected new conflict for ${file.path} during upload attempt. Re-resolving.`);
        if (chosenConflictResolution === void 0) {
          let resolutionStrategy = this.settings.conflictResolution;
          if (this.settings.realtimeSync || this.settings.syncOnSave && !this.settings.realtimeSync) {
            resolutionStrategy = "local";
          } else if (resolutionStrategy === "ask") {
            const modal = new ConflictResolutionModal(this.app, file.path, localContent, remoteContentFromGitHub);
            chosenConflictResolution = await modal.askForResolution();
            console.log(`[Upload Conflict Resolution] User selected resolution for ${file.path}: ${chosenConflictResolution}`);
          } else {
            chosenConflictResolution = resolutionStrategy;
            console.log(`[Upload Conflict Resolution] Applying automatic resolution for ${file.path}: ${chosenConflictResolution}`);
          }
        }
        switch (chosenConflictResolution) {
          case "local":
            contentToPush = localContent;
            shaForPut = currentRemoteSha;
            break;
          case "remote":
            contentToPush = remoteContentFromGitHub;
            await this.app.vault.modify(file, remoteContentFromGitHub);
            console.log(`[Upload Conflict Resolution] Overwrote local ${file.path} with remote version.`);
            shaForPut = currentRemoteSha;
            break;
          case "merge":
            contentToPush = await this.mergeContent(localContent, remoteContentFromGitHub);
            await this.app.vault.modify(file, contentToPush);
            console.log(`[Upload Conflict Resolution] Merged ${file.path}.`);
            shaForPut = currentRemoteSha;
            break;
          default:
            contentToPush = localContent;
            console.warn(`[Upload Conflict Resolution] Unexpected resolution state. Defaulting to local.`);
            shaForPut = currentRemoteSha;
        }
        const resolvedContentChecksum = await this.calculateChecksum(contentToPush);
        metadata.githubBlobSha = shaForPut || "";
        metadata.lastModified = Date.now();
        metadata.localChecksum = resolvedContentChecksum;
        metadata.remoteContentChecksum = resolvedContentChecksum;
        metadata.conflicted = false;
        await this.savePluginData();
      } else if (currentRemoteSha === void 0) {
        shaForPut = void 0;
      } else {
        shaForPut = currentRemoteSha;
      }
      const requestBody = {
        message: shaForPut ? `Update ${file.name} (Obsidian SyncMate)` : `Add ${file.name} (Obsidian SyncMate)`,
        content: this.encodeBase64(contentToPush),
        branch: this.settings.branch
      };
      if (shaForPut) {
        requestBody.sha = shaForPut;
        console.log(`[Upload] Using SHA for PUT request: ${shaForPut}`);
      } else {
        console.log("[Upload] No existing SHA found, creating new file.");
      }
      try {
        const encodedRemotePath = this.encodeFilePath(remotePath);
        const result = await this.makeGitHubRequest(
          `/repos/${this.settings.repoOwner}/${this.settings.repoName}/contents/${encodedRemotePath}`,
          {
            method: "PUT",
            body: requestBody
          }
        );
        const finalLocalChecksum = await this.calculateChecksum(contentToPush);
        metadata.githubBlobSha = result.content.sha;
        metadata.lastModified = file.stat.mtime;
        metadata.localChecksum = finalLocalChecksum;
        metadata.remoteContentChecksum = finalLocalChecksum;
        metadata.conflicted = false;
        this.syncState.fileMetadata.set(file.path, metadata);
        await this.savePluginData();
        console.log(`[Upload] Successfully uploaded ${file.path} to GitHub with SHA: ${result.content.sha}`);
        return;
      } catch (error) {
        if (error.status === 409 && currentAttempt < maxRetries) {
          console.warn(`[Upload Error] Conflict (409) for ${file.path}, retrying attempt ${currentAttempt}/${maxRetries}...`);
          await new Promise((resolve) => setTimeout(resolve, 1e3 * currentAttempt));
        } else {
          console.error(`[Upload Error] Error uploading file ${file.path} after ${currentAttempt} attempts:`, error);
          throw error;
        }
      }
    }
  }
  // Ensures that the directory structure for a given file path exists in the local vault.
  async ensureDirectoryExists(filePath) {
    const pathParts = filePath.split("/");
    pathParts.pop();
    if (pathParts.length === 0) return;
    let currentPath = "";
    for (const part of pathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        try {
          console.log(`Creating folder: ${currentPath}`);
          await this.app.vault.createFolder(currentPath);
        } catch (error) {
          if (!(error instanceof Error && error.message.includes("Folder already exists"))) {
            console.warn(`Path ${currentPath} exists but is a file, not a folder. This might cause issues.`);
          }
        }
      } else if (folder instanceof import_obsidian.TFile) {
        console.warn(`Path ${currentPath} exists but is a file, not a folder. This might cause issues.`);
      }
    }
  }
  // Encodes file paths for safe use in GitHub API URLs.
  encodeFilePath(path) {
    return path.split("/").map((segment) => encodeURIComponent(segment)).join("/");
  }
  // Centralized confirmation modal for user prompts.
  async showConfirmationModal(title, message) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText(title);
      const contentEl = modal.contentEl;
      contentEl.createEl("p", { text: message });
      const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
      buttonContainer.style.display = "flex";
      buttonContainer.style.gap = "10px";
      buttonContainer.style.justifyContent = "flex-end";
      buttonContainer.style.marginTop = "20px";
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.onclick = () => {
        modal.close();
        resolve(false);
      };
      const confirmBtn = buttonContainer.createEl("button", { text: "Confirm" });
      confirmBtn.style.backgroundColor = "var(--interactive-accent)";
      confirmBtn.style.color = "var(--text-on-accent)";
      confirmBtn.onclick = () => {
        modal.close();
        resolve(true);
      };
      modal.open();
    });
  }
  // Opens the FileHistoryModal for a specific TFile.
  openFileHistoryModal(file) {
    if (!this.validateSettings()) {
      this.debouncedShowNotice("Please configure GitHub settings to view history.", "error");
      return;
    }
    new FileHistoryModal(this.app, this, file).open();
  }
  // Opens the FolderHistoryModal for a specific TFolder.
  openFolderHistoryModal(folder) {
    if (!this.validateSettings()) {
      this.debouncedShowNotice("Please configure GitHub settings to view folder history.", "error");
      return;
    }
    new FolderHistoryModal(this.app, this, folder).open();
  }
};
var CommitContentModal = class extends import_obsidian.Modal {
  // Reference to the main plugin instance.
  constructor(app, plugin, fileName, content, sourcePath) {
    super(app);
    this.plugin = plugin;
    this.fileName = fileName;
    this.content = content;
    this.sourcePath = sourcePath;
    this.titleEl.setText(`Content of: ${fileName}`);
  }
  // Configures the modal's appearance and renders content when opened.
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "80vw";
    this.modalEl.style.maxWidth = "800px";
    this.modalEl.style.height = "80vh";
    this.modalEl.style.maxHeight = "800px";
    this.modalEl.style.display = "flex";
    this.modalEl.style.flexDirection = "column";
    const markdownContainer = contentEl.createDiv({ cls: "markdown-render-view" });
    markdownContainer.style.flexGrow = "1";
    markdownContainer.style.overflowY = "auto";
    markdownContainer.style.padding = "10px";
    markdownContainer.style.border = "1px solid var(--background-modifier-border)";
    markdownContainer.style.borderRadius = "8px";
    markdownContainer.style.backgroundColor = "var(--background-secondary)";
    import_obsidian.MarkdownRenderer.renderMarkdown(this.content, markdownContainer, this.sourcePath, this.plugin);
  }
  // Cleans up content when the modal is closed.
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FileHistoryModal = class extends import_obsidian.Modal {
  // Loading indicator element.
  constructor(app, plugin, file) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    this.titleEl.setText(`Version History for: ${file.name}`);
  }
  // Configures the modal layout and initiates history fetching when opened.
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const mainContainer = contentEl.createDiv({ cls: "github-sync-history-main-container" });
    mainContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 80vh; 
        `;
    this.loadingEl = mainContainer.createEl("div", { text: "Loading history... \u23F3", cls: "github-sync-loading" });
    this.loadingEl.style.cssText = `
            font-style: italic;
            color: var(--text-muted);
            padding: 10px;
            text-align: center;
        `;
    this.historyContainer = mainContainer.createDiv({ cls: "github-sync-history-list-container" });
    this.historyContainer.style.cssText = `
            flex-grow: 1;
            max-height: 75vh;
            overflow-y: auto;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            padding: 10px;
        `;
    try {
      await this.fetchAndDisplayHistory();
    } catch (error) {
      console.error("Error fetching file history:", error);
      this.loadingEl.setText(`Failed to load history: ${error.message}. Please check console.`);
      this.loadingEl.style.color = "var(--text-error)";
    }
  }
  // Placeholder for cleanup when the modal is closed.
  onClose() {
  }
  // Fetches and displays the commit history for the associated file.
  async fetchAndDisplayHistory() {
    this.loadingEl.setText("Loading history... \u23F3");
    this.historyContainer.empty();
    const remotePath = this.plugin.getRemotePath(this.file.path);
    const branch = this.plugin.settings.branch;
    try {
      const commits = await this.plugin.makeGitHubRequest(
        `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/commits?path=${this.plugin.encodeFilePath(remotePath)}&sha=${branch}`
      );
      this.loadingEl.remove();
      if (!Array.isArray(commits) || commits.length === 0) {
        this.historyContainer.createEl("p", { text: "No version history found for this file on GitHub.", cls: "github-sync-info" });
        this.historyContainer.style.cssText = `
                    font-style: italic;
                    color: var(--text-muted);
                    padding: 10px;
                    text-align: center;
                `;
        return;
      }
      for (const commit of commits) {
        const commitEl = this.historyContainer.createDiv({ cls: "github-sync-commit-item" });
        commitEl.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    padding: 8px;
                    border: 1px solid var(--background-modifier-border);
                    border-radius: 8px;
                    margin-bottom: 5px;
                    background-color: var(--background-secondary); 
                `;
        const headerEl = commitEl.createDiv();
        headerEl.style.cssText = "display: flex; justify-content: space-between; align-items: center;";
        const messageEl = headerEl.createEl("div", { text: commit.commit.message, cls: "github-sync-commit-message" });
        messageEl.style.cssText = "font-weight: bold; margin-bottom: 4px; flex-grow: 1;";
        const shaEl = headerEl.createEl("div", { text: `SHA: ${commit.sha.substring(0, 7)}`, cls: "github-sync-commit-sha" });
        shaEl.style.cssText = "font-family: monospace; font-size: 0.85em; color: var(--text-muted); margin-left: 10px;";
        const authorEl = commitEl.createEl("div", { text: `Author: ${commit.commit.author.name}`, cls: "github-sync-commit-author" });
        authorEl.style.cssText = "font-size: 0.9em; color: var(--text-normal);";
        const dateEl = commitEl.createEl("div", { text: `Date: ${new Date(commit.commit.author.date).toLocaleString()}`, cls: "github-sync-commit-date" });
        dateEl.style.cssText = "font-size: 0.9em; color: var(--text-normal);";
        const actionsEl = commitEl.createDiv({ cls: "github-sync-commit-actions" });
        actionsEl.style.cssText = "display: flex; gap: 8px; margin-top: 8px; justify-content: flex-end;";
        const viewBtn = actionsEl.createEl("button", { text: "View" });
        viewBtn.style.cssText = `
                    background-color: var(--interactive-accent);
                    color: var(--text-on-accent);
                    border: none;
                    border-radius: 6px;
                    padding: 6px 12px;
                    cursor: pointer;
                    transition: background-color 0.2s ease;
                `;
        viewBtn.onmouseover = (e) => e.target.style.backgroundColor = "var(--interactive-accent-hover)";
        viewBtn.onmouseout = (e) => e.target.style.backgroundColor = "var(--interactive-accent)";
        viewBtn.onclick = () => this.viewVersionContent(commit.sha, remotePath);
        const restoreBtn = actionsEl.createEl("button", { text: "Restore" });
        restoreBtn.style.cssText = `
                    background-color: var(--background-modifier-error); 
                    color: var(--text-on-accent);
                    border: none;
                    border-radius: 6px;
                    padding: 6px 12px;
                    cursor: pointer;
                    transition: background-color 0.2s ease;
                `;
        restoreBtn.onmouseover = (e) => e.target.style.backgroundColor = "var(--background-modifier-error-hover)";
        restoreBtn.onmouseout = (e) => e.target.style.backgroundColor = "var(--background-modifier-error)";
        restoreBtn.onclick = () => this.restoreVersion(commit.sha, remotePath);
      }
    } catch (error) {
      console.error("Failed to fetch and display history:", error);
      this.loadingEl.setText(`Error fetching history: ${error.message}.`);
      this.loadingEl.style.color = "var(--text-error)";
    }
  }
  // Fetches and displays the content of a specific file version from GitHub.
  async viewVersionContent(commitSha, remotePath) {
    try {
      this.plugin.debouncedShowNotice(`Fetching content for ${commitSha.substring(0, 7)}...`, "info", 1500);
      const fileData = await this.plugin.makeGitHubRequest(
        `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/contents/${this.plugin.encodeFilePath(remotePath)}?ref=${commitSha}`
      );
      const content = this.plugin.decodeBase64(fileData.content);
      new CommitContentModal(this.app, this.plugin, this.file.name, content, this.file.path).open();
    } catch (error) {
      console.error(`Error viewing version ${commitSha}:`, error);
      let errorMessage = `Failed to view version: ${error.message}`;
      if (error.status === 404) {
        errorMessage = `Version not found: The file may not exist at this path in commit ${commitSha.substring(0, 7)}.`;
      }
      this.plugin.debouncedShowNotice(errorMessage, "error", 4e3);
    }
  }
  // Restores a specific version of the file to the local vault.
  async restoreVersion(commitSha, remotePath) {
    const confirmed = await this.plugin.showConfirmationModal(
      // Uses centralized confirmation modal.
      "Confirm Restore Version",
      `Are you sure you want to restore "${this.file.name}" to the version from commit ${commitSha.substring(0, 7)}? This will overwrite your local file and create a NEW commit on GitHub to revert its content.`
    );
    if (!confirmed) {
      this.plugin.debouncedShowNotice("Restore cancelled.", "info", 2e3);
      return;
    }
    try {
      this.plugin.debouncedShowNotice(`Restoring "${this.file.name}" to version ${commitSha.substring(0, 7)}...`, "info", 2e3);
      const fileData = await this.plugin.makeGitHubRequest(
        `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/contents/${this.plugin.encodeFilePath(remotePath)}?ref=${commitSha}`
      );
      const historicalContent = this.plugin.decodeBase64(fileData.content);
      await this.app.vault.modify(this.file, historicalContent);
      this.plugin.debouncedShowNotice(`Successfully restored "${this.file.name}". It will be pushed to GitHub shortly.`, "success", 4e3);
      this.close();
    } catch (error) {
      console.error(`Error restoring version ${commitSha}:`, error);
      let errorMessage = `Failed to restore version: ${error.message}`;
      if (error.status === 404) {
        errorMessage = `Version not found: The file may not exist at this path in commit ${commitSha.substring(0, 7)}.`;
      }
      this.plugin.debouncedShowNotice(errorMessage, "error", 5e3);
    }
  }
};
var FolderHistoryModal = class extends import_obsidian.Modal {
  // Loading indicator element.
  constructor(app, plugin, folder) {
    super(app);
    this.plugin = plugin;
    this.folder = folder;
    this.titleEl.setText(`GitHub Folder History: ${folder.name || "Vault Root"}`);
  }
  // Configures the modal layout and initiates folder history fetching.
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const mainContainer = contentEl.createDiv({ cls: "github-sync-folder-history-main-container" });
    mainContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 80vh;
        `;
    this.loadingEl = mainContainer.createEl("div", { text: "Loading folder history... \u23F3", cls: "github-sync-loading" });
    this.loadingEl.style.cssText = `
            font-style: italic;
            color: var(--text-muted);
            padding: 10px;
            text-align: center;
        `;
    this.historyContainer = mainContainer.createDiv({ cls: "github-sync-history-list-container" });
    this.historyContainer.style.cssText = `
            flex-grow: 1;
            max-height: 75vh;
            overflow-y: auto;
            border: 1px solid var(--background-modifier-border);
            border-radius: 8px;
            padding: 10px;
        `;
    try {
      await this.fetchAndDisplayFolderHistory();
    } catch (error) {
      console.error("Error fetching folder history:", error);
      this.loadingEl.setText(`Failed to load folder history: ${error.message}. Please check console.`);
      this.loadingEl.style.color = "var(--text-error)";
    }
  }
  // Placeholder for cleanup when the modal is closed.
  onClose() {
  }
  // Fetches and displays the commit history for the associated folder.
  async fetchAndDisplayFolderHistory() {
    this.loadingEl.setText("Loading folder history... \u23F3");
    this.historyContainer.empty();
    const folderRemotePath = this.plugin.getRemotePath(this.folder.path);
    const branch = this.plugin.settings.branch;
    try {
      const commits = await this.plugin.makeGitHubRequest(
        `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/commits?path=${this.plugin.encodeFilePath(folderRemotePath)}&sha=${branch}`
      );
      this.loadingEl.remove();
      if (!Array.isArray(commits) || commits.length === 0) {
        this.historyContainer.createEl("p", { text: "No version history found for this folder on GitHub.", cls: "github-sync-info" });
        this.historyContainer.style.cssText = `
                    font-style: italic;
                    color: var(--text-muted);
                    padding: 10px;
                    text-align: center;
                `;
        return;
      }
      for (const commit of commits) {
        const commitEl = this.historyContainer.createDiv({ cls: "github-sync-commit-item" });
        commitEl.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    padding: 8px;
                    border: 1px solid var(--background-modifier-border);
                    border-radius: 8px;
                    margin-bottom: 10px; 
                    background-color: var(--background-secondary); 
                `;
        const headerEl = commitEl.createDiv();
        headerEl.style.cssText = "display: flex; justify-content: space-between; align-items: center;";
        const messageEl = headerEl.createEl("div", { text: commit.commit.message, cls: "github-sync-commit-message" });
        messageEl.style.cssText = "font-weight: bold; margin-bottom: 4px; flex-grow: 1;";
        const shaEl = headerEl.createEl("div", { text: `SHA: ${commit.sha.substring(0, 7)}`, cls: "github-sync-commit-sha" });
        shaEl.style.cssText = "font-family: monospace; font-size: 0.85em; color: var(--text-muted); margin-left: 10px;";
        const authorEl = commitEl.createEl("div", { text: `Author: ${commit.commit.author.name}`, cls: "github-sync-commit-author" });
        authorEl.style.cssText = "font-size: 0.9em; color: var(--text-normal);";
        const dateEl = commitEl.createEl("div", { text: `Date: ${new Date(commit.commit.author.date).toLocaleString()}`, cls: "github-sync-commit-date" });
        dateEl.style.cssText = "font-size: 0.9em; color: var(--text-normal);";
        const filesContainer = commitEl.createDiv({ cls: "github-sync-files-container" });
        filesContainer.setText("Loading changed files...");
        filesContainer.style.cssText = `
                    margin-top: 10px;
                    padding-top: 10px;
                    border-top: 1px solid var(--background-modifier-border-hover);
                `;
        try {
          const detailedCommit = await this.plugin.makeGitHubRequest(
            `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/commits/${commit.sha}`
          );
          filesContainer.empty();
          const relevantFiles = detailedCommit.files.filter(
            (file) => file.filename.startsWith(folderRemotePath === "" ? "" : `${folderRemotePath}/`) && this.plugin.isMarkdownFile(file.filename)
          );
          if (relevantFiles.length > 0) {
            for (const file of relevantFiles) {
              const fileChangeItemEl = filesContainer.createDiv({ cls: "github-sync-file-change-item" });
              fileChangeItemEl.style.cssText = `
                                display: flex;
                                flex-direction: column;
                                padding: 6px 10px; 
                                border: 1px solid var(--background-modifier-border-hover); 
                                border-radius: 6px;
                                margin-bottom: 5px; 
                                background-color: var(--background-primary); 
                            `;
              let fileNameDisplay = file.filename.substring(folderRemotePath.length).replace(/^\//, "");
              let statusIcon = "";
              let statusColor = "var(--text-normal)";
              switch (file.status) {
                case "added":
                  statusIcon = "\u2795";
                  statusColor = "var(--text-success)";
                  break;
                case "modified":
                  statusIcon = "\u270F\uFE0F";
                  statusColor = "var(--text-normal)";
                  break;
                case "removed":
                  statusIcon = "\u2796";
                  statusColor = "var(--text-error)";
                  break;
                case "renamed":
                  statusIcon = "\u{1F504}";
                  statusColor = "var(--text-accent)";
                  const oldName = file.previous_filename.substring(folderRemotePath.length).replace(/^\//, "");
                  fileNameDisplay = `${oldName} \u2192 ${fileNameDisplay}`;
                  break;
                default:
                  statusIcon = "\u2139\uFE0F";
              }
              const fileItemHeader = fileChangeItemEl.createDiv();
              fileItemHeader.style.cssText = "display: flex; justify-content: space-between; align-items: center; width: 100%;";
              const fileInfoSpan = fileItemHeader.createEl("span");
              fileInfoSpan.style.cssText = "flex-grow: 1; margin-right: 10px;";
              fileInfoSpan.innerHTML = `<span style="color: ${statusColor}; margin-right: 5px;">${statusIcon}</span> <span style="font-weight: 500;">${fileNameDisplay}</span>`;
              const actionsEl = fileItemHeader.createDiv({ cls: "github-sync-file-actions" });
              actionsEl.style.cssText = "display: flex; gap: 8px;";
              if (file.status !== "removed") {
                const viewBtn = actionsEl.createEl("button", { text: "View" });
                viewBtn.style.cssText = `
                                    background-color: var(--interactive-accent);
                                    color: var(--text-on-accent);
                                    border: none;
                                    border-radius: 6px;
                                    padding: 6px 12px;
                                    cursor: pointer;
                                    transition: background-color 0.2s ease;
                                `;
                viewBtn.onmouseover = (e) => e.target.style.backgroundColor = "var(--interactive-accent-hover)";
                viewBtn.onmouseout = (e) => e.target.style.backgroundColor = "var(--interactive-accent)";
                viewBtn.onclick = () => this.viewFileContentFromCommit(commit.sha, file.filename);
                const restoreBtn = actionsEl.createEl("button", { text: "Restore" });
                restoreBtn.style.cssText = `
                                    background-color: var(--background-modifier-error); 
                                    color: var(--text-on-accent);
                                    border: none;
                                    border-radius: 6px;
                                    padding: 6px 12px;
                                    cursor: pointer;
                                    transition: background-color 0.2s ease;
                                `;
                restoreBtn.onmouseover = (e) => e.target.style.backgroundColor = "var(--background-modifier-error-hover)";
                restoreBtn.onmouseout = (e) => e.target.style.backgroundColor = "var(--background-modifier-error)";
                restoreBtn.onclick = () => this.restoreFileFromCommit(commit.sha, file.filename);
              }
            }
          } else {
            filesContainer.createEl("p", { text: "No files changed in this commit within this folder.", cls: "github-sync-no-files-changed" });
            filesContainer.style.cssText += "font-style: italic; color: var(--text-muted);";
          }
        } catch (detailedCommitError) {
          console.error(`Failed to fetch details for commit ${commit.sha}:`, detailedCommitError);
          filesContainer.setText("Error loading changed files.");
          filesContainer.style.color = "var(--text-error)";
        }
      }
    } catch (error) {
      console.error("Failed to fetch and display folder history:", error);
      this.loadingEl.setText(`Error fetching folder history: ${error.message}.`);
      this.loadingEl.style.color = "var(--text-error)";
    }
  }
  // Views the content of a specific file from a given commit in the folder history.
  async viewFileContentFromCommit(commitSha, fileRemotePathAtCommit) {
    try {
      this.plugin.debouncedShowNotice(`Fetching content for ${fileRemotePathAtCommit} at commit ${commitSha.substring(0, 7)}...`, "info", 1500);
      const fileData = await this.plugin.makeGitHubRequest(
        `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/contents/${this.plugin.encodeFilePath(fileRemotePathAtCommit)}?ref=${commitSha}`
      );
      const content = this.plugin.decodeBase64(fileData.content);
      const localFilePath = this.plugin.getLocalPath(fileRemotePathAtCommit);
      new CommitContentModal(this.app, this.plugin, fileRemotePathAtCommit.split("/").pop() || "Unnamed File", content, localFilePath).open();
    } catch (error) {
      console.error(`Error viewing file ${fileRemotePathAtCommit} at commit ${commitSha}:`, error);
      let errorMessage = `Failed to view content: ${error.message}`;
      if (error.status === 404) {
        errorMessage = `Content not found. The file may have been renamed or deleted before this commit.`;
      } else if (error.message.includes("Failed to decode base64")) {
        errorMessage = `Failed to decode file content. This may indicate a non-text file or corrupted content.`;
      }
      this.plugin.debouncedShowNotice(errorMessage, "error", 5e3);
    }
  }
  // Restores a specific file from a given commit within the folder history.
  async restoreFileFromCommit(commitSha, fileRemotePathAtCommit) {
    const fileName = fileRemotePathAtCommit.split("/").pop() || fileRemotePathAtCommit;
    const confirmed = await this.plugin.showConfirmationModal(
      "Confirm Restore Version",
      `Are you sure you want to restore "${fileName}" to its state from commit ${commitSha.substring(0, 7)}? This will overwrite your current local file (or create it if deleted). The change will be pushed to GitHub on the next sync.`
    );
    if (!confirmed) {
      this.plugin.debouncedShowNotice("Restore cancelled.", "info", 2e3);
      return;
    }
    try {
      this.plugin.debouncedShowNotice(`Restoring "${fileName}"...`, "info", 2e3);
      const fileData = await this.plugin.makeGitHubRequest(
        `/repos/${this.plugin.settings.repoOwner}/${this.plugin.settings.repoName}/contents/${this.plugin.encodeFilePath(fileRemotePathAtCommit)}?ref=${commitSha}`
      );
      const historicalContent = this.plugin.decodeBase64(fileData.content);
      const localPath = this.plugin.getLocalPath(fileRemotePathAtCommit);
      const existingFile = this.app.vault.getAbstractFileByPath(localPath);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, historicalContent);
      } else {
        await this.plugin.ensureDirectoryExists(localPath);
        await this.app.vault.create(localPath, historicalContent);
      }
      this.plugin.debouncedShowNotice(`Successfully restored "${fileName}". It will be uploaded on the next sync.`, "success", 4e3);
    } catch (error) {
      console.error(`Error restoring file ${fileRemotePathAtCommit} from commit ${commitSha}:`, error);
      this.plugin.debouncedShowNotice(`Failed to restore file: ${error.message}`, "error", 5e3);
    }
  }
};
var GitHubSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  // Checks if the environment is mobile.
  isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "ontouchstart" in window || window.innerWidth <= 768;
  }
  // Displays the settings interface.
  display() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "GitHub SyncMate Settings" });
    containerEl.createEl("h3", { text: "GitHub Configuration" });
    new import_obsidian.Setting(containerEl).setName("GitHub Personal Access Token").setDesc("Your GitHub Personal Access Token (PAT). This is essential for authentication and requires 'repo' scope.").addText((text) => {
      text.setPlaceholder("ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx").setValue(this.plugin.settings.githubToken).onChange(async (value) => {
        this.plugin.settings.githubToken = value;
        await this.plugin.savePluginData();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian.Setting(containerEl).setName("Repository Owner").setDesc("The GitHub username or organization that owns the repository (e.g., your-username or your-org).").addText((text) => text.setPlaceholder("e.g., your-username or your-org").setValue(this.plugin.settings.repoOwner).onChange(async (value) => {
      this.plugin.settings.repoOwner = value;
      await this.plugin.savePluginData();
    }));
    new import_obsidian.Setting(containerEl).setName("Repository Name").setDesc("The name of your GitHub repository (e.g., 'my-obsidian-vault').").addText((text) => text.setPlaceholder("e.g., my-obsidian-vault").setValue(this.plugin.settings.repoName).onChange(async (value) => {
      this.plugin.settings.repoName = value;
      await this.plugin.savePluginData();
    }));
    new import_obsidian.Setting(containerEl).setName("Branch").setDesc("The specific branch in your GitHub repository to synchronize with (e.g., main, master, develop).").addText((text) => text.setPlaceholder("main").setValue(this.plugin.settings.branch).onChange(async (value) => {
      this.plugin.settings.branch = value;
      await this.plugin.savePluginData();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Path").setDesc("The subfolder within your GitHub repository to synchronize (e.g., 'notes', 'daily-journal'). Leave this field blank to sync with the repository root.").addText((text) => text.setPlaceholder("e.g., notes/Daily").setValue(this.plugin.settings.syncPath).onChange(async (value) => {
      this.plugin.settings.syncPath = value.trim().replace(/^\/|\/$/g, "");
      await this.plugin.savePluginData();
    }));
    new import_obsidian.Setting(containerEl).setName("Test GitHub Connection").setDesc("Verifies your GitHub Personal Access Token and repository settings to ensure connectivity.").addButton((button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
      button.setButtonText("Testing...");
      button.setDisabled(true);
      try {
        await this.plugin.testConnection();
        button.setButtonText("\u2705 Success");
      } catch (error) {
        button.setButtonText("\u274C Failed");
      }
      setTimeout(() => {
        button.setButtonText("Test Connection");
        button.setDisabled(false);
      }, 2e3);
    }));
    containerEl.createEl("h3", { text: "Sync Behavior" });
    new import_obsidian.Setting(containerEl).setName("Real-time Sync").setDesc("Enables synchronization of notes with GitHub as you type. This feature is currently disabled and reserved for future development.").addToggle((toggle) => toggle.setValue(this.plugin.settings.realtimeSync).onChange(async (value) => {
      this.plugin.settings.realtimeSync = value;
      await this.plugin.savePluginData();
      this.plugin.updateOverallStatusBar();
    }).setDisabled(true));
    new import_obsidian.Setting(containerEl).setName("Sync on Save").setDesc("Triggers a synchronization every time a file is saved in Obsidian. This feature is currently disabled.").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnSave).onChange(async (value) => {
      this.plugin.settings.syncOnSave = value;
      await this.plugin.savePluginData();
    }).setDisabled(true));
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically synchronizes your vault with GitHub at regular, configurable intervals.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.savePluginData();
      if (value) {
        this.plugin.startAutoSync();
        this.plugin.syncWithGitHub("Auto Sync");
      } else {
        this.plugin.stopAutoSync();
      }
      this.plugin.updateOverallStatusBar();
    }));
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc("Defines how often (in minutes) the plugin should automatically synchronize with GitHub.").addSlider((slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.syncInterval / 6e4).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.syncInterval = value * 6e4;
      await this.plugin.savePluginData();
      if (this.plugin.settings.autoSync) {
        this.plugin.startAutoSync();
      }
    }));
    containerEl.createEl("h3", { text: "Conflict Resolution" });
    new import_obsidian.Setting(containerEl).setName("Conflict Resolution Strategy").setDesc("Selects the default method for resolving conflicts when a file is modified both locally and remotely.").addDropdown((dropdown) => dropdown.addOption("ask", "Ask me each time").addOption("local", "Keep Local Version").addOption("remote", "Prefer GitHub Version").addOption("merge", "Attempt Auto-Merge").setValue(this.plugin.settings.conflictResolution).onChange(async (value) => {
      this.plugin.settings.conflictResolution = value;
      await this.plugin.savePluginData();
    }));
    containerEl.createEl("h3", { text: "Notifications" });
    new import_obsidian.Setting(containerEl).setName("Notification Verbosity").setDesc("Controls the level of detail for synchronization notifications displayed by the plugin.").addDropdown((dropdown) => dropdown.addOption("quiet", "Quiet").addOption("standard", "Standard").addOption("verbose", "Verbose").setValue(this.plugin.settings.notificationVerbosity).onChange(async (value) => {
      this.plugin.settings.notificationVerbosity = value;
      await this.plugin.savePluginData();
    }));
    containerEl.createEl("h3", { text: "Advanced Operations" });
    new import_obsidian.Setting(containerEl).setName("Force Pull from GitHub").setDesc("\u26A0\uFE0F **DANGER ZONE:** Downloads all files from your GitHub repository, **overwriting all local versions**. Any unsaved local changes will be permanently lost. Use with extreme caution.").addButton((button) => button.setButtonText("Force Pull").setWarning().onClick(async () => {
      const confirmed = await this.plugin.showConfirmationModal(
        "Confirm Force Pull Confirmation",
        "This action will download and overwrite ALL local files with versions from GitHub. Any unsaved local changes will be lost. Are you absolutely sure you want to proceed?"
      );
      if (confirmed) {
        button.setButtonText("Pulling...");
        button.setDisabled(true);
        try {
          await this.plugin.forcePullFromGitHub();
          button.setButtonText("\u2705 Done");
        } catch (error) {
          button.setButtonText("\u274C Failed");
        }
        setTimeout(() => {
          button.setButtonText("Force Pull");
          button.setDisabled(false);
        }, 2e3);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Force Push to GitHub").setDesc("\u26A0\uFE0F **DANGER ZONE:** Uploads all local files to your GitHub repository, **overwriting all remote changes**. Any changes made by others on GitHub will be permanently lost. Use with extreme caution.").addButton((button) => button.setButtonText("Force Push").setWarning().onClick(async () => {
      const confirmed = await this.plugin.showConfirmationModal(
        "Confirm Force Push Confirmation",
        "This action will upload and overwrite ALL files on GitHub with your local versions. Any changes made by others will be lost. Are you absolutely sure you want to proceed?"
      );
      if (confirmed) {
        button.setButtonText("Pushing...");
        button.setDisabled(true);
        try {
          await this.plugin.forcePushToGitHub();
          button.setButtonText("\u2705 Done");
        } catch (error) {
          button.setButtonText("\u274C Failed");
        }
        setTimeout(() => {
          button.setButtonText("Force Push");
          button.setDisabled(false);
        }, 2e3);
      }
    }));
    containerEl.createEl("h3", { text: "Sync Status & Info" });
    const statusContainer = containerEl.createDiv({ cls: "sync-status" });
    const lastSyncTime = this.plugin.settings.lastSyncTime;
    const lastSyncText = lastSyncTime ? `Last sync: ${new Date(lastSyncTime).toLocaleString()}` : "Never synced";
    statusContainer.createEl("div", {
      text: lastSyncText,
      cls: "setting-item-description"
    });
    const pendingFilesCount = ((_b = (_a = this.plugin.syncState) == null ? void 0 : _a.pendingFiles) == null ? void 0 : _b.size) || 0;
    const pendingFilesText = `Pending files for upload: ${pendingFilesCount}`;
    const pendingFilesEl = statusContainer.createEl("div", {
      text: pendingFilesText,
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(statusContainer).setName("Refresh Status").setDesc("Updates the displayed last synchronization time and pending file count.").addButton((button) => button.setButtonText("Refresh").onClick(() => {
      this.display();
    }));
    containerEl.createEl("h3", { text: "About This Plugin" });
    containerEl.createEl("p", { text: "This Obsidian plugin provides robust synchronization of your Markdown notes with a GitHub repository, offering version control and backup capabilities for your digital garden." });
    containerEl.createEl("p", { text: "Plugin Version: 1.0.0" });
    containerEl.createEl("p", { text: "Compatibility: \u2705 Android, iOS, Windows, Mac, Linux" });
    containerEl.createEl("h3", { text: "Support & Contribution" });
    containerEl.createEl("p", { text: "For support, bug reports, or feature requests, please visit the official " }).createEl("a", { text: "GitHub repository", href: "https://github.com/cybawizz/GitHubSyncMate" }).setAttr("target", "_blank");
    containerEl.createEl("p", { text: "Consider supporting ongoing development via " }).createEl("a", { text: "Buy Me a Coffee", href: "https://buymeacoffee.com/cybawizz" }).setAttr("target", "_blank");
  }
};
function customDebounce(func, wait, immediate) {
  let timeout;
  return function(...args) {
    const context = this;
    const later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    const callNow = immediate && !timeout;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}
